<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kirmes in Kettig - Dienstplan 2025</title>
    
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Papa Parse for CSV processing -->
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    
    <!-- html2pdf for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        /* Print styles */
        @media print {
            body, html {
                height: auto !important;
                overflow: visible !important;
                font-family: Arial, sans-serif !important;
                background: white !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            body * { 
                visibility: hidden; 
                background-color: white !important;
                color: black !important;
            }
            
            .content-section, .content-section * { 
                visibility: visible; 
                color: black !important;
            }
            
            .content-section { 
                position: relative !important; /* Changed from absolute to relative */
                left: 0; 
                top: 0; 
                width: 100%; 
                background-color: white !important;
                height: auto !important;
                overflow: visible !important;
                padding: 0 !important;
                margin: 0 !important;
                font-family: Arial, sans-serif !important;
                float: none !important;
                display: block !important;
            }
            
            /* Compact PDF-like layout for print */
            .content-section > div {
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            .task-card {
                break-inside: avoid !important;
                page-break-inside: avoid !important;
                border: 1px solid #ccc !important;
                margin-bottom: 8px !important; /* Reduced from 10px */
                margin-top: 0 !important;
                background-color: white !important;
                box-shadow: none !important;
                padding: 8px !important; /* Reduced from 10px */
                font-size: 10pt !important; /* Reduced from 11pt */
            }
            
            /* Optimize spacing */
            .task-header {
                margin-bottom: 3px !important; /* Reduced from 5px */
            }
            
            .task-title {
                color: #333 !important;
                font-weight: bold !important;
                border-bottom: 1px solid #ddd !important;
                font-size: 11pt !important; /* Reduced from 12pt */
                margin: 0 0 3px 0 !important; /* Reduced from 5px */
            }
            
            .task-date-time {
                font-size: 9pt !important; /* Reduced from 10pt */
            }
            
            .task-date-time span {
                margin: 0 !important;
                padding: 0 !important;
                line-height: 1.1 !important; /* Reduced from 1.2 */
            }
            
            /* Make task cards take up less vertical space */
            .task-card h4 {
                font-size: 9pt !important; /* Reduced size */
                margin: 3px 0 !important; /* Reduced margins */
            }
            
            /* Person tags */
            .person-tag {
                display: inline !important;
                background: none !important;
                border: none !important;
                padding: 0 !important;
                margin-right: 10px !important;
                font-size: 10pt !important;
            }
            
            /* All task persons in a single line to save space */
            div > div:last-child > div {
                display: block !important;
            }
            
            h4 {
                font-size: 10pt !important;
                margin: 5px 0 !important;
            }
            
            /* Highlighted person */
            .person-tag[style*="searchTerm"] {
                font-weight: bold !important;
            }
            
            /* Page settings */
            @page { 
                size: portrait; 
                margin: 1.0cm !important; /* Reduced margins to fit more content */
            }
            
            /* Remove any float or overflow issues that might cause extra pages */
            * {
                float: none !important;
                position: static !important;
                overflow: visible !important;
            }
            
            .header-section,
            .search-clear-btn,
            .nav-btn,
            .filter-container,
            .secondary-filters,
            .print-hide {
                display: none !important;
            }
            
            /* PDF-style header for print */
            .content-section::before {
                content: "Kirmes in Kettig - Dienstplan 2025";
                font-size: 16pt !important;
                font-weight: bold !important;
                display: block !important;
                text-align: center !important;
                margin-bottom: 5px !important;
                color: black !important;
            }
            
            /* Add subtitle with person's name after the title */
            .content-section::after {
                content: var(--print-subtitle);
                font-size: 14pt !important;
                display: block !important;
                text-align: center !important;
                margin-bottom: 15px !important;
                color: #000 !important;
                margin-top: 5px !important;
            }
            
            /* Compact person listing */
            .content-section .task-card h4 + div {
                display: block !important;
                margin-bottom: 5px !important;
                font-size: 10pt !important;
            }
            
            /* Style for arrow and highlighting person name */
            .content-section .task-card .person-tag[style*="searchTerm"] {
                font-weight: bold !important;
                background-color: #ffeb99 !important; /* Light yellow background */
                padding: 1px 3px !important;
                border-radius: 3px !important;
                color: #000 !important;
            }
            
            .content-section .task-card .person-tag[style*="searchTerm"]::after {
                content: " ←";
                font-weight: bold !important;
            }
            
            /* Add print header as a regular element instead of pseudo-element */
            .content-section {
                position: relative !important;
            }
            
            .content-section::before {
                content: "Kirmes in Kettig - Dienstplan 2025";
                display: block !important;
                position: static !important; /* Changed from fixed to static */
                width: 100% !important;
                text-align: center !important;
                font-size: 16pt !important;
                font-weight: bold !important;
                margin-bottom: 5px !important;
                padding-top: 5mm !important;
                background: white !important;
                border-bottom: 2px solid #ff0000 !important; /* Red line under title */
                padding-bottom: 2px !important;
            }
            
            /* Add subtitle with search term below header */
            .content-section > div::before {
                content: var(--print-subtitle);
                display: block !important;
                position: static !important; /* Ensure position is static */
                text-align: center !important;
                font-size: 14pt !important;
                font-weight: bold !important; /* Make the person name bold */
                margin-bottom: 15px !important;
                color: #000 !important; /* Darker color to match PDF */
                border-bottom: 1px dotted #ccc !important;
                padding-bottom: 10px !important;
            }
            
            /* Footer with date and personalized message */
            .content-section > div::after {
                content: var(--print-footer);
                display: block !important;
                position: static !important; /* Ensure position is static */
                text-align: center !important;
                font-size: 9pt !important;
                margin-top: 10px !important;
                color: #666 !important;
                border-top: 0 !important; /* Remove border */
                padding-top: 10px !important;
                white-space: pre !important; /* Preserve newlines in content */
                line-height: 1.4 !important;
                font-style: italic !important;
            }
            
            /* Make the task cards more compact */
            .task-card {
                margin-bottom: 5mm !important;
                border-radius: 5px !important;
            }
            
            /* Make the task title more compact */
            .task-card div:first-child {
                padding-bottom: 5px !important;
                margin-bottom: 5px !important;
            }
            
            /* Position elements better */
            .task-header {
                align-items: center !important;
            }
            
            /* More compact spacing on persons list */
            .task-card h4 {
                margin-top: 0 !important;
            }
            
            /* Allow the subtitle to show by NOT removing the ::after element */
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #0a0a0a 100%);
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        
        /* Animation keyframes */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Ripple effect animation for person tags */
        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        /* Pulse animation for selected person tags */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 215, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 215, 0, 0);
            }
        }
        
        /* Main layout for task viewer */
        .main-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding-top: 0; /* Let the content-section handle spacing */
            position: relative;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Force any fixed position elements to stay in place during transitions */
        body {
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Additional class to force content below header - adjusted gap */
        .force-content-below-header .content-section {
            margin-top: 320px !important; /* Slightly increased to avoid overlap */
            padding-top: 50px !important; /* Increased buffer */
            position: relative;
            z-index: 1000; /* Below header but above other content */
        }
        
        /* Style to apply on initial page load to prevent overlap before JS runs */
        .initial-load .content-section {
            padding-top: 320px !important; /* Increased initial padding to prevent overlap */
            margin-top: 10px !important; /* Small margin during initial load */
            transition: padding-top 0.5s ease-in-out, margin-top 0.5s ease-in-out; /* Faster transition for better user experience */
            position: relative;
            z-index: 1000; /* Below header but above other content */
        }
        
        /* Sticky header with filters */
        .header-section {
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 2000; /* Even higher z-index to absolutely ensure header stays above everything */
            padding: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease, visibility 0.3s ease;
            will-change: transform, opacity, visibility;
            /* Force hardware acceleration for smoother transitions */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }
        
        /* Special styling for header when sticked to top and visible */
        .header-section.sticky-visible {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Scrollable content area */
        .content-section {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-top: 300px; /* Increased initial safe padding - will be adjusted by JavaScript */
            margin-top: 0; /* Ensure no extra margin */
            position: relative;
            z-index: 1; /* Ensure content stays BELOW header */
            /* Padding-top will be set dynamically by JavaScript */
            transition: padding-top 0.3s ease; /* Smooth transitions for padding changes */
            will-change: padding-top; /* Optimize for animation */
            box-sizing: border-box; /* Include padding in height calculation */
        }
        
        /* Ensure task cards have proper spacing and never overlay header */
        .task-card {
            margin-bottom: 20px;
            position: relative;
            z-index: 1; /* Ensure task cards stack below the header */
            transition: transform 0.3s ease; /* Smooth animation when recalculating positions */
            /* Additional styling to ensure cards stand out */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        /* Force header to always be above content */
        .header-section.sticky-visible {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            z-index: 2000 !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3) !important;
        }
        
        /* Export menu styling - ensure it's always visible and properly positioned */
        .export-menu {
            position: sticky !important;
            top: 390px !important; /* Position it just below the header - increased to match new spacing */
            z-index: 1500 !important;
            transition: all 0.3s ease !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;
            margin-bottom: 20px !important; /* Add some space below the export menu */
        }
        
        /* When header is hidden, adjust position accordingly */
        body.force-content-below-header .export-menu {
            top: 390px !important; /* Increased to match new spacing */
            margin-top: 20px !important; /* Add space from top of content */
        }
        
        /* Handle initial page load state for export menu */
        .initial-load .export-menu {
            top: 320px !important; /* Lower initial position to match the screenshot */
            position: relative !important; /* Start as relative to ensure proper placement */
            z-index: 1600 !important; /* Slightly higher z-index during initial load */
        }
        
        /* When header is manually hidden, adjust position for export menu */
        .manually-hidden-header .export-menu {
            top: 50px !important;
        }
        
        /* Ensure export buttons have proper visibility */
        .export-buttons {
            gap: 8px !important;
        }
        
        /* Header toggle button */
        .header-toggle-btn {
            transition: all 0.2s ease;
        }
        
        .header-toggle-btn:hover {
            background: rgba(255, 215, 0, 0.3) !important;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        .header-toggle-btn:active {
            transform: translateX(-50%) translateY(1px) !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3) !important;
        }
        
        /* Filter container */
        .filter-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        
        /* Animation for the collapsible instruction box */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulseHighlight {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
            40% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); }
            60% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); }
            100% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .filter-container {
                padding: 10px;
            }
            
            .filter-container h1 {
                font-size: 1.5rem !important;
                margin: 0 !important;
            }
            
            .filter-container p {
                font-size: 0.9rem !important;
                margin: 3px 0 0 0 !important;
            }
            
            .primary-search {
                margin: 15px auto !important;
            }
            
            .primary-search input {
                padding: 15px 40px 15px 15px !important;
                font-size: 16px !important;
            }
            
            .secondary-filters {
                gap: 8px !important;
                margin-top: 10px !important;
            }
            
            .filter-select {
                padding: 8px 10px !important;
                font-size: 12px !important;
                min-width: 90px !important;
            }
            
            .nav-btn {
                padding: 6px 12px !important;
                font-size: 11px !important;
            }
            
            /* Mobile task cards */
            .content-section {
                padding: 10px !important;
                /* Add margin at top to account for the header sliding out */
                padding-top: 15px !important;
            }
            
            .task-card {
                padding: 15px !important;
                margin-bottom: 10px !important;
            }
            
            .task-title {
                font-size: 1.1rem !important;
            }
            
            .task-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 10px !important;
            }
            
            .task-date-time {
                align-items: flex-start !important;
                text-align: left !important;
            }
            
            .task-info {
                flex-direction: column !important;
                gap: 8px !important;
                align-items: flex-start !important;
            }
            
            .task-info span {
                font-size: 0.9rem !important;
            }
            
            .person-tag {
                font-size: 12px !important;
                padding: 4px 8px !important;
            }
            
            /* Selected person tag styles */
            .person-tag.selected {
                background: rgba(255, 215, 0, 0.4) !important;
                border: 1px solid rgba(255, 215, 0, 0.8) !important;
                color: #000 !important;
                box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3) !important;
                animation: pulseHighlight 0.4s ease, pulse 1.5s infinite !important;
                font-weight: 600 !important;
                transform: translateY(-2px) !important;
            }
            
            /* Improved mobile header appearance */
            .header-section {
                padding: 10px 5px !important;
                transition: transform 0.3s ease, opacity 0.3s ease !important;
                will-change: transform, opacity;
                position: fixed !important;
                width: 100% !important;
                top: 0 !important;
                left: 0 !important;
                z-index: 1000 !important;
            }
            
            /* Content section handles its own padding on mobile */
            .main-layout {
                padding-top: 0 !important; /* Let the content section handle spacing */
            }
            
            /* Content section on mobile - dynamic padding handled by JS */
            .content-section {
                position: relative !important;
                z-index: 5 !important; /* Below header but above other elements */
                /* Base padding to be dynamically adjusted by JS */
            }
            
            /* Instructions on mobile */
            .header-section button {
                min-width: 36px !important;
                min-height: 36px !important;
            }
            
            /* Header hiding - simplified for better performance */
            .header-section.header-hidden {
                /* Use transform for smoother animations - this property is GPU accelerated */
                transform: translateY(-100%) !important;
                /* Make it completely invisible */
                opacity: 0 !important;
                /* Prevent interaction with hidden element */
                pointer-events: none !important;
                /* Accessibility & SEO considerations */
                visibility: hidden !important;
                /* For older browsers & complete hiding */
                position: absolute !important;
                top: -9999px !important;
            }
            
            /* Visible header */
            .header-section {
                transform: translateY(0);
                opacity: 1;
                pointer-events: auto;
                visibility: visible;
                position: fixed !important;
                transition: transform 0.3s ease, opacity 0.2s ease;
            }
            
            /* Mobile search bar improvements */
            .primary-search input:focus {
                outline: none;
                border-color: #FFD700;
                background: rgba(0, 0, 0, 0.4);
                box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
            }
            
            /* Super small screens */
            @media (max-width: 380px) {
                .filter-container h1 {
                    font-size: 1.2rem !important;
                }
                
                .primary-search input {
                    font-size: 14px !important;
                    padding: 10px 40px 10px 12px !important;
                }
                
                /* Vertical alignment for filter controls */
                .filter-controls {
                    flex-direction: column !important;
                    align-items: stretch !important;
                    width: 100% !important;
                }
                
                .filter-select, .task-search input {
                    width: 100% !important;
                }
                
                .task-search {
                    width: 100% !important;
                }
                
                /* Compact secondary filters */
                .secondary-filters {
                    flex-direction: column !important;
                    align-items: stretch !important;
                }
                
                .filter-select, .task-search-combo {
                    width: 100% !important;
                    margin-bottom: 8px !important;
                }
                
                .nav-btn {
                    align-self: center !important;
                }
            }
            
            /* Special styling for active search on mobile */
            @media (max-width: 480px) {
                .primary-search:focus-within {
                    position: relative;
                    z-index: 200;
                }
                
                .primary-search:focus-within input {
                    box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3);
                }
            }
        }
        
        /* Primary search (name) */
        .primary-search {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            position: relative;
        }
        
        .primary-search input {
            width: 100%;
            padding: 20px 50px 20px 20px; /* Add right padding for X button */
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #FFD700;
            font-size: 18px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .primary-search input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        /* Search input optimizations for mobile */
        @media (max-width: 480px) {
            .primary-search input {
                padding: 12px 30px 12px 12px;
                font-size: 16px;
                text-align: left;
            }
        }
        
        .primary-search input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
        }
        
        /* Clear button inside search field */
        .search-clear-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 215, 0, 0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }
        
        .search-clear-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        
        /* Secondary filters */
        .secondary-filters {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        /* Responsive adjustments for secondary filters */
        @media (max-width: 480px) {
            .secondary-filters {
                gap: 8px;
                margin-top: 10px;
            }
            
            .filter-select, .task-search-combo {
                flex: 1;
                min-width: 0;
            }
            
            /* Make buttons more tap-friendly on mobile */
            .nav-btn, 
            .search-clear-btn,
            .task-dropdown-btn,
            .task-search-clear {
                min-width: 36px;
                min-height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* Filter controls */
        .filter-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .filter-select, .filter-input {
            padding: 10px 14px;
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.25);
            color: #FFD700;
            font-size: 13px;
            min-width: 110px;
        }
        
        .filter-select:focus, .filter-input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15);
        }
        
        .filter-select option {
            background: #1a1a1a;
            color: #FFD700;
        }
        
        /* Task search combo input */
        .task-search-combo {
            position: relative;
            min-width: 200px;
        }
        
        .task-search-combo input {
            width: 100%;
            padding: 10px 50px 10px 14px; /* More space for dropdown arrow and clear button */
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.25);
            color: #FFD700;
            font-size: 13px;
        }
        
        .task-search-combo input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        .task-search-combo input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15);
        }
        
        .task-dropdown-btn {
            position: absolute;
            right: 28px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 215, 0, 0.7);
            font-size: 12px;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            transition: all 0.2s ease;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .task-dropdown-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        
        .task-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 2px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .task-dropdown-item {
            padding: 8px 12px;
            color: #FFD700;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }
        
        .task-dropdown-item:hover {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .task-dropdown-item:last-child {
            border-bottom: none;
        }

        /* Task search input */
        .task-search {
            position: relative;
            min-width: 200px;
        }
        
        .task-search input {
            width: 100%;
            padding: 10px 30px 10px 14px;
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.25);
            color: #FFD700;
            font-size: 13px;
        }
        
        .task-search input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        .task-search input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15);
        }
        
        .task-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 215, 0, 0.7);
            font-size: 14px;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            transition: all 0.2s ease;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .task-search-clear:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        

        
        .container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .glass-card {
            background: rgba(255, 215, 0, 0.05); /* Subtle gold tint */
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 215, 0, 0.15); /* Subtle gold border */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            padding: 40px;
            width: 100%;
            max-width: 1200px;
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .login-card {
            max-width: 400px;
            text-align: center;
        }
        
        .title {
            color: #FFD700; /* Kirmes gold */
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            color: rgba(255, 215, 0, 0.8); /* Gold tint */
            font-size: 1.1rem;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        
        .form-label {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
        }
        
        .form-input {
            width: 100%;
            padding: 15px 20px;
            border: 1px solid rgba(255, 215, 0, 0.3); /* Gold border */
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3); /* Dark background */
            color: #FFD700; /* Gold text */
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .form-input::placeholder {
            color: rgba(255, 215, 0, 0.6); /* Gold placeholder */
        }
        
        .form-input:focus {
            outline: none;
            border-color: #FFD700; /* Gold focus border */
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
        }
        
        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #FFD700, #FFA500); /* Kirmes gold gradient */
            color: #000; /* Black text on gold */
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.3);
            background: linear-gradient(135deg, #FFA500, #FFD700);
        }
        
        .error-message {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .search-input {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #FFD700;
            font-size: 18px;
            margin: 0 auto 30px auto;
            display: block;
        }
        
        .search-input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        .search-input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
        }
        
        .nav-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .nav-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.2); /* Gold tint */
            color: #FFD700; /* Gold text */
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .nav-btn:hover, .nav-btn.active {
            background: rgba(255, 215, 0, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
        }
        
        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .status-success {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.4);
            color: #28a745;
        }
        
        .status-info {
            background: rgba(23, 162, 184, 0.2);
            border: 1px solid rgba(23, 162, 184, 0.4);
            color: #17a2b8;
        }
        
        /* Clickable person tags styling */
        .person-tag {
            cursor: pointer;
            position: relative;
            transition: all 0.25s ease;
            touch-action: manipulation; /* Improve touch behavior */
            -webkit-tap-highlight-color: transparent; /* Remove default mobile tap highlight */
        }
        
        .person-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            background: rgba(255, 215, 0, 0.25) !important;
            border-color: rgba(255, 215, 0, 0.5) !important;
        }
        
        .person-tag:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: all 0.1s ease;
        }
        
        /* Badge for selected tags */
        .person-tag.selected::after {
            content: "✓";
            position: absolute;
            top: -8px;
            right: -8px;
            background: #FFD700;
            color: #000;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 0, 0, 0.1);
            animation: fadeIn 0.3s ease;
        }
    </style>
    <!-- Smart header styles -->
    <!-- Removed external smart-header.css - all styles now inline in React component -->
</head>
<body>
    <!-- Modern clean background -->
    
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Local Storage utilities
        const StorageKeys = {
            TASKS: 'kirmes_tasks_data',
            LOGIN_STATUS: 'kirmes_login_status',
            ADMIN_STATUS: 'kirmes_admin_status'
        };
        
        const loadFromStorage = (key, defaultValue = null) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (error) {
                console.error('Error loading from storage:', error);
                return defaultValue;
            }
        };
        
        // CSV Processing
        const processCSV = (csvText) => {
            return new Promise((resolve, reject) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: ';', // German CSV uses semicolon
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.error('CSV parsing errors:', results.errors);
                        }
                        
                        // Transform CSV data to our format - MAINTAIN ORDER
                        const tasks = [];
                        
                        results.data.forEach((row, index) => {
                            // Parse assigned persons (separated by semicolon in quotes)
                            const assignedPersons = row.Zugewiesene_Personen || '';
                            const persons = assignedPersons.split(';').map(p => p.trim().replace(/"/g, '')).filter(p => p);
                            
                            // If there are no assigned persons, create a single task entry without persons
                            if (persons.length === 0) {
                                tasks.push({
                                    id: `${index}-empty`,
                                    originalOrder: index, // Keep original CSV order
                                    name: '', // Empty name for unassigned tasks
                                    task: row.Aufgabe || '',
                                    date: row.Tag || '',
                                    time: row.Zeit || '',
                                    location: row.Standort || '',
                                    taskId: row.Task_ID || '',
                                    status: row.Status || ''
                                });
                            } else {
                                // Create individual tasks for each person, but keep them grouped
                                persons.forEach((person, personIndex) => {
                                    tasks.push({
                                        id: `${index}-${personIndex}`,
                                        originalOrder: index, // Keep original CSV order
                                        name: person,
                                        task: row.Aufgabe || '',
                                        date: row.Tag || '',
                                        time: row.Zeit || '',
                                        location: row.Standort || '',
                                        taskId: row.Task_ID || '',
                                        status: row.Status || ''
                                    });
                                });
                            }
                        });
                        
                        // Sort by original order to maintain chronological sequence - include ALL tasks
                        const validTasks = tasks
                            .filter(task => task.task && task.task.length > 0) // Only filter out tasks without task names
                            .sort((a, b) => a.originalOrder - b.originalOrder);
                        
                        // Debug stats for task count
                        const tasksByDay = {};
                        validTasks.forEach(task => {
                            if (!tasksByDay[task.date]) tasksByDay[task.date] = 0;
                            tasksByDay[task.date]++;
                        });
                        
                        const emptyTasks = validTasks.filter(task => !task.name || task.name.length === 0);
                        
                        resolve(validTasks);
                    },
                    error: function(error) {
                        reject(error);
                    }
                });
            });
        };
        
        // Login Component - Password Only
        const LoginPage = ({ onLogin, onWrongPassword, error }) => {
            const [password, setPassword] = useState('');
            
            const handleLogin = (e) => {
                e.preventDefault();
                if (password === 'kirmes2025') {  // Main login password
                    onLogin();
                } else {
                    onWrongPassword();
                    setPassword(''); // Clear password field
                }
            };
            
            return (
                <div className="container">
                    <div className="glass-card login-card">
                        <h1 className="title">Kirmes in Kettig</h1>
                        <p className="subtitle">Dienstplan 2025</p>
                        
                        {error && (
                            <div className="error-message">{error}</div>
                        )}
                        
                        <form onSubmit={handleLogin}>
                            <div className="form-group">
                                <label className="form-label">Passwort eingeben</label>
                                <input
                                    type="password"
                                    className="form-input"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    placeholder="Passwort für Dienstplan..."
                                    required
                                />
                            </div>
                            <button type="submit" className="btn">
                                Dienstplan anzeigen
                            </button>
                        </form>
                        
                        <div style={{ marginTop: '20px', fontSize: '14px', color: 'rgba(255, 255, 255, 0.7)' }}>
                            <p>Das Passwort findest du in der Kirmes WhatsApp Gruppe</p>
                        </div>
                    </div>
                </div>
            );
        };
        
        // Task Viewer Component - Modern Layout with Filters
        const TaskViewer = React.memo(({ tasks }) => {
            // Add debug log to track when component actually re-renders vs re-mounts
            console.log("TaskViewer RENDER (not re-mount) - tasks count:", tasks.length);
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedDay, setSelectedDay] = useState('');
            const [selectedTask, setSelectedTask] = useState('');
            const [taskSearchTerm, setTaskSearchTerm] = useState('');
            const [showTaskDropdown, setShowTaskDropdown] = useState(false);
            
            // Get unique days and tasks for filters
            const uniqueDays = [...new Set(tasks.map(task => task.date))].filter(Boolean);
            const uniqueTasks = [...new Set(tasks.map(task => task.task))].filter(Boolean).sort();
            
            // Sort days in Kirmes order: Freitag, Samstag, Sonntag, Montag, Dienstag, Mittwoch
            const dayOrder = ['Freitag', 'Samstag', 'Sonntag', 'Montag', 'Dienstag', 'Mittwoch'];
            const sortedDays = uniqueDays.sort((a, b) => {
                const indexA = dayOrder.indexOf(a);
                const indexB = dayOrder.indexOf(b);
                // If day not found in order, put it at the end
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });
            
            // Filter tasks for dropdown based on search term
            const filteredDropdownTasks = uniqueTasks.filter(task => 
                task.toLowerCase().includes(taskSearchTerm.toLowerCase())
            );
            
            // Handle task input changes
            const handleTaskInputChange = (e) => {
                const value = e.target.value;
                setTaskSearchTerm(value);
                setSelectedTask(''); // Clear selection when typing
                setShowTaskDropdown(value.length > 0); // Show dropdown when typing
            };
            
            // Helper function to force recalculate content padding
            const forceUpdateContentPadding = (withDebug = false) => {
                const header = document.querySelector('.header-section');
                const content = document.querySelector('.content-section');
                const exportMenu = document.querySelector('.export-menu');
                
                if (header && content) {
                    // If manually hidden, ensure we use the minimum padding
                    if (manuallyHidden) {
                        content.style.paddingTop = '40px';
                        return;
                    }
                    
                    // Force header to be visible for measurement
                    const originalDisplay = header.style.display;
                    const originalVisibility = header.style.visibility;
                    const originalOpacity = header.style.opacity;
                    const originalTransform = header.style.transform;
                    
                    header.style.display = 'block';
                    header.style.visibility = 'visible';
                    header.style.opacity = '1';
                    header.style.transform = 'translateY(0)';
                    
                    // Force reflow
                    void header.offsetHeight;
                    
                    // Get accurate height
                    const headerHeight = header.offsetHeight;
                    
                    // NEW: Calculate exact position where tasks should start
                    let idealTaskStartPosition = headerHeight;
                    
                    // Add buffer for export menu if it exists and is visible
                    if (exportMenu && window.getComputedStyle(exportMenu).display !== 'none') {
                        const exportMenuHeight = exportMenu.offsetHeight || 50;
                        idealTaskStartPosition += exportMenuHeight + 20; // 20px margin
                    }
                    
                    // Calculate optimal padding with minimal buffer
                    const optimalBuffer = 20; // Much smaller buffer
                    const finalPadding = idealTaskStartPosition + optimalBuffer;
                    
                    content.style.paddingTop = `${finalPadding}px`;
                    
                    // Restore original properties if needed
                    if (manuallyHidden) {
                        header.style.display = originalDisplay;
                        header.style.visibility = originalVisibility;
                        header.style.opacity = originalOpacity;
                        header.style.transform = originalTransform;
                        
                        // Adjust export menu position if it exists
                        if (exportMenu) {
                            exportMenu.style.top = '50px';
                        }
                    } else if (exportMenu) {
                        // Normal position when header is visible - use dynamic calculation
                        const dynamicTop = headerHeight + 20; // Header height + small buffer
                        exportMenu.style.top = `${dynamicTop}px`;
                    }
                    
                    if (withDebug) {
                        // Reduce console spam - only log on significant changes
                        const significantChange = Math.abs(headerHeight - (window.lastLoggedHeight || 0)) > 10;
                        if (significantChange) {
                            console.log('🔧 Force update content padding:', {
                                headerHeight: headerHeight,
                                idealTaskStart: idealTaskStartPosition,
                                finalPadding: finalPadding,
                                manuallyHidden: manuallyHidden,
                                gapReduction: `${80 - optimalBuffer}px saved`
                            });
                            window.lastLoggedHeight = headerHeight;
                        }
                    }
                }
            };
            
            const handleTaskSelect = (task) => {
                setTaskSearchTerm(task);
                setSelectedTask(task);
                setShowTaskDropdown(false);
                // Force update padding after selection changes with debug info
                setTimeout(() => forceUpdateContentPadding(true), 100);
                // Second check with a longer delay
                setTimeout(() => forceUpdateContentPadding(false), 500);
            };
            
            const clearTaskSearch = () => {
                setTaskSearchTerm('');
                setSelectedTask('');
                setShowTaskDropdown(false);
                // Force update padding after clearing with debug info
                setTimeout(() => forceUpdateContentPadding(true), 100);
                // Second check with a longer delay
                setTimeout(() => forceUpdateContentPadding(false), 500);
            };
            
            // Group tasks by their original order (chronological)
            const groupTasksByOriginal = (tasks) => {
                const taskGroups = {};
                tasks.forEach(task => {
                    const key = `${task.date}-${task.time}-${task.location}-${task.task}`;
                    if (!taskGroups[key]) {
                        taskGroups[key] = {
                            date: task.date,
                            time: task.time,
                            location: task.location,
                            task: task.task,
                            taskId: task.taskId,
                            persons: []
                        };
                    }
                    // Only add person if they exist (not empty for unassigned tasks)
                    if (task.name && task.name.length > 0) {
                        taskGroups[key].persons.push(task.name);
                    }
                });
                return Object.values(taskGroups);
            };
            
            const groupedTasks = groupTasksByOriginal(tasks);
            
            // Function to update export menu position based on header state
            const updateExportMenuPosition = () => {
                const exportMenu = document.querySelector('.export-menu');
                if (!exportMenu) return;
                
                const body = document.body;
                const isInitialLoad = body.classList.contains('initial-load');
                const header = document.querySelector('.header-section');
                
                if (manuallyHidden) {
                    exportMenu.style.top = '50px';
                    exportMenu.style.position = 'sticky';
                } else if (isInitialLoad) {
                    // During initial load, position to match screenshot
                    exportMenu.style.top = '320px';
                    exportMenu.style.position = 'relative';
                    exportMenu.style.marginTop = '10px';
                } else {
                    // Normal state - calculate dynamically based on actual header height
                    if (header) {
                        const headerHeight = header.offsetHeight || 194; // Fallback
                        const dynamicTop = headerHeight + 20; // Header height + small buffer
                        exportMenu.style.top = `${dynamicTop}px`;
                        exportMenu.style.position = 'sticky';
                        
                        console.log('📊 Export menu positioned dynamically:', {
                            headerHeight: headerHeight,
                            exportMenuTop: dynamicTop
                        });
                    } else {
                        // Fallback to static positioning
                        exportMenu.style.top = '220px'; // Optimized fallback
                        exportMenu.style.position = 'sticky';
                    }
                }
            };
            
            // Filter tasks based on all criteria
            const filteredTasks = groupedTasks.filter(task => {
                // For name search: if no search term, show all tasks
                // If search term exists, show only tasks with matching persons
                const matchesName = searchTerm.trim() === '' || 
                    task.persons.some(person => 
                        person.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                
                const matchesDay = selectedDay === '' || task.date === selectedDay;
                
                // Task filter: check both dropdown selection and search term
                const matchesTask = (selectedTask === '' || task.task === selectedTask) &&
                    (taskSearchTerm.trim() === '' || task.task.toLowerCase().includes(taskSearchTerm.toLowerCase()));
                
                return matchesName && matchesDay && matchesTask;
            });
            
            // Smart header that hides on scroll down, shows on scroll up
            const [headerVisible, setHeaderVisible] = useState(true);
            const [lastScrollY, setLastScrollY] = useState(0);
            // Start with collapsed instructions by default
            const [isExpanded, setIsExpanded] = useState(false);
            // User can manually toggle header visibility
            const [manuallyHidden, setManuallyHidden] = useState(false);
            
            // Handle scroll events for smart header
            useEffect(() => {
                console.log("Setting up scroll handlers - React version");
                
                // Check for presence of required elements and log results
                const headerElement = document.querySelector('.header-section');
                const contentElement = document.querySelector('.content-section');
                console.log("Elements check:", { 
                    header: headerElement ? "Found" : "Missing",
                    content: contentElement ? "Found" : "Missing"
                });
                
                // Variable to track touch direction for mobile
                // Enhanced scroll detection system for container-based scrolling
                let lastScrollPosition = 0;
                let scrollDirection = 'none';
                let scrollTimer = null;
                let isScrolling = false;
                let currentVisibleTaskIndex = 0;
                let totalTasks = filteredTasks.length;
                let isInitialMount = true; // Flag to prevent auto-hide during initial mount
                
                // Minimum scroll distance to trigger header hide/show
                const SCROLL_THRESHOLD = 100;
                const SCROLL_TOP_THRESHOLD = 50;
                
                // Get the actual scroll container (content-section)
                const getScrollContainer = () => {
                    return document.querySelector('.content-section');
                };
                
                // Calculate which task is currently visible at the top of the viewport
                const calculateVisibleTaskIndex = (scrollContainer) => {
                    if (!scrollContainer) return 0;
                    
                    const taskCards = scrollContainer.querySelectorAll('.task-card');
                    const containerRect = scrollContainer.getBoundingClientRect();
                    const scrollTop = scrollContainer.scrollTop;
                    
                    // Find the first task that's visible in the viewport
                    for (let i = 0; i < taskCards.length; i++) {
                        const taskRect = taskCards[i].getBoundingClientRect();
                        const relativeTop = taskRect.top - containerRect.top + scrollTop;
                        
                        if (relativeTop >= scrollTop - 50) { // 50px buffer
                            return i;
                        }
                    }
                    
                    return Math.max(0, taskCards.length - 1); // Default to last task if at bottom
                };
                
                // Enhanced scroll handler that works with the content container
                const handleScroll = (event) => {
                    const scrollContainer = event?.target || getScrollContainer();
                    if (!scrollContainer || scrollContainer.className !== 'content-section') {
                        return; // Only handle scroll events from the content section
                    }
                    
                    if (scrollTimer) {
                        clearTimeout(scrollTimer);
                    }
                    
                    isScrolling = true;
                    
                    scrollTimer = setTimeout(() => {
                        const currentScrollY = scrollContainer.scrollTop;
                        const scrollDelta = currentScrollY - lastScrollPosition;
                        
                        // Determine scroll direction with threshold to avoid micro-movements
                        if (Math.abs(scrollDelta) > 5) {
                            if (scrollDelta > 0) {
                                scrollDirection = 'down';
                            } else {
                                scrollDirection = 'up';
                            }
                        }
                        
                        // Calculate current visible task
                        const newVisibleTaskIndex = calculateVisibleTaskIndex(scrollContainer);
                        const taskIndexChanged = newVisibleTaskIndex !== currentVisibleTaskIndex;
                        currentVisibleTaskIndex = newVisibleTaskIndex;
                        
                        // Calculate scroll percentage
                        const maxScroll = scrollContainer.scrollHeight - scrollContainer.clientHeight;
                        const scrollPercentage = maxScroll > 0 ? (currentScrollY / maxScroll) * 100 : 0;
                        
                        // Enhanced debug logging with task information
                        console.log('📊 Enhanced Scroll Event:', {
                            position: Math.round(currentScrollY),
                            delta: Math.round(scrollDelta),
                            direction: scrollDirection,
                            headerState: manuallyHidden ? 'HIDDEN' : 'VISIBLE',
                            visibleTaskIndex: currentVisibleTaskIndex + 1, // Show 1-based index
                            totalTasks: totalTasks,
                            scrollPercentage: Math.round(scrollPercentage),
                            willTrigger: shouldTriggerHeaderChange(currentScrollY, scrollDirection),
                            taskChanged: taskIndexChanged
                        });
                        
                        // Apply header logic based on scroll position and direction
                        handleHeaderVisibility(currentScrollY, scrollDirection);
                        
                        lastScrollPosition = currentScrollY;
                        isScrolling = false;
                    }, 50); // 50ms debounce - prevents too frequent updates
                };
                
                // Determine if header state should change
                const shouldTriggerHeaderChange = (scrollY, direction) => {
                    // Always show at top
                    if (scrollY <= SCROLL_TOP_THRESHOLD) return true;
                    
                    // Hide when scrolling down past threshold
                    if (direction === 'down' && scrollY > SCROLL_THRESHOLD && !manuallyHidden) return true;
                    
                    // Don't auto-show when scrolling up (user must use button)
                    return false;
                };
                
                // Handle header visibility changes
                const handleHeaderVisibility = (scrollY, direction) => {
                    // Don't trigger auto-hide during initial mount to prevent conflicts with manual toggles
                    if (isInitialMount) {
                        console.log('🚫 Skipping auto-hide during initial mount, scrollY:', scrollY, 'direction:', direction);
                        return;
                    }
                    
                    // Case 1: At the very top - always show header
                    if (scrollY <= SCROLL_TOP_THRESHOLD) {
                        if (manuallyHidden) {
                            console.log('🔝 At top - showing header (scrollY:', scrollY, ')');
                            toggleHeaderManually();
                        }
                        return;
                    }
                    
                    // Case 2: Auto-hide when scrolling down past task 2
                    if (direction === 'down' && currentVisibleTaskIndex >= 2 && !manuallyHidden) {
                        console.log('⬇️ Auto-hiding header - past task 2, current task index:', currentVisibleTaskIndex + 1);
                        
                        // Also collapse instructions if they're expanded
                        if (isExpanded) {
                            console.log('📝 Auto-collapsing instructions');
                            setIsExpanded(false);
                        }
                        
                        // Hide the header
                        toggleHeaderManually();
                        return;
                    }
                    
                    // Case 3: Already hidden and scrolling further down - do nothing
                    if (direction === 'down' && manuallyHidden) {
                        console.log('⬇️ Scrolling down with header already hidden - no action needed, task index:', currentVisibleTaskIndex + 1);
                        return;
                    }
                    
                    // Case 4: Scrolling up - header stays hidden (user must manually show header)
                    if (direction === 'up' && manuallyHidden) {
                        console.log('⬆️ Scrolling up - header stays hidden (manual toggle required), task index:', currentVisibleTaskIndex + 1);
                        return;
                    }
                };
                
                // Touch handling for mobile devices (simplified)
                let touchStartY = 0;
                let touchMoveTimer = null;
                
                const handleTouchStart = (e) => {
                    touchStartY = e.touches[0].clientY;
                };
                
                const handleTouchMove = (e) => {
                    // Only handle touch moves when not already scrolling via scroll events
                    if (isScrolling) return;
                    
                    if (touchMoveTimer) clearTimeout(touchMoveTimer);
                    
                    const touchY = e.touches[0].clientY;
                    const touchDelta = touchStartY - touchY;
                    
                    // Debounce touch moves
                    touchMoveTimer = setTimeout(() => {
                        // Only trigger on significant touch movement
                        if (Math.abs(touchDelta) > 20) {
                            const touchDirection = touchDelta > 0 ? 'down' : 'up';
                            
                            // Get current scroll position from the content container
                            const scrollContainer = getScrollContainer();
                            const currentScrollY = scrollContainer ? scrollContainer.scrollTop : 0;
                            
                            console.log('👆 Touch movement:', {
                                delta: Math.round(touchDelta),
                                direction: touchDirection,
                                scrollY: Math.round(currentScrollY),
                                taskIndex: currentVisibleTaskIndex
                            });
                            
                            // Apply same logic as scroll
                            handleHeaderVisibility(currentScrollY, touchDirection);
                        }
                        
                        touchStartY = touchY;
                    }, 100); // Longer debounce for touch
                };
                
                // Add event listeners to the correct scroll container
                const scrollContainer = getScrollContainer();
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', handleScroll, { passive: true });
                    console.log('📦 Attached scroll listener to content-section container');
                } else {
                    console.warn('⚠️ Content section not found, falling back to window scroll');
                    window.addEventListener('scroll', handleScroll, { passive: true });
                }
                
                // Touch events still go on window since they're global gestures
                window.addEventListener('touchstart', handleTouchStart, { passive: true });
                window.addEventListener('touchmove', handleTouchMove, { passive: true });
                
                // Update total tasks when filtered tasks change
                totalTasks = filteredTasks.length;
                
                // Set initial mount flag to false after a short delay to allow manual toggles to work
                const initialMountTimer = setTimeout(() => {
                    isInitialMount = false;
                    console.log('✅ Initial mount period ended - auto-hide logic now active');
                }, 1000); // 1 second delay to prevent conflicts with manual button presses
                
                // Also handle scroll button visibility separately from header visibility
                const updateScrollButtonVisibility = () => {
                    const scrollButton = document.getElementById('scrollTopButton');
                    const scrollContainer = getScrollContainer();
                    const currentScroll = scrollContainer ? scrollContainer.scrollTop : window.scrollY;
                    
                    if (scrollButton) {
                        // Always show the scroll button (except on login screen)
                        scrollButton.style.opacity = '1';
                        scrollButton.style.pointerEvents = 'auto';
                        scrollButton.style.transform = 'scale(1)';
                    }
                    
                    // Update the header toggle button appearance and text
                    const toggleBtn = document.getElementById('header-toggle-button');
                    if (toggleBtn) {
                        toggleBtn.style.opacity = currentScroll > 10 ? '0.9' : '0.6';
                        
                        // Update button text based on header state
                        // If manually hidden (either by button press or auto-hide when scrolling), show "Show search"
                        if (manuallyHidden || (currentScroll > 80 && !headerVisible)) {
                            toggleBtn.textContent = '▲ Suche anzeigen';
                        } else {
                            toggleBtn.textContent = '▼ Suche ausblenden';
                        }
                    }
                };
                
                // Attach scroll button update to the correct container
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', updateScrollButtonVisibility, { passive: true });
                } else {
                    window.addEventListener('scroll', updateScrollButtonVisibility, { passive: true });
                }
                // Call immediately to set initial state
                setTimeout(updateScrollButtonVisibility, 100);
                
                // Listen for resize events to optimize for mobile
                const handleResize = () => {
                    // Set smaller initial search bar padding on mobile
                    if (window.innerWidth < 480) {
                        const searchInput = document.querySelector('.primary-search input');
                        if (searchInput) {
                            searchInput.style.padding = '12px 30px 12px 12px';
                            searchInput.style.fontSize = '16px';
                        }
                    }
                    
                    // Always adjust content padding based on header height
                    // This works for all screen sizes but is especially important for mobile
                    const headerHeight = document.querySelector('.header-section')?.offsetHeight || 180;
                    const mainLayout = document.querySelector('.main-layout');
                    if (mainLayout) {
                        mainLayout.style.paddingTop = `${headerHeight}px`;
                    }
                };
                
                window.addEventListener('resize', handleResize);
                // Call once on mount to apply styles
                handleResize();
                
                // Check header height after a short delay to ensure all content is rendered
                setTimeout(handleResize, 500);
                
                return () => {
                    // Clean up all event listeners
                    const scrollContainer = getScrollContainer();
                    if (scrollContainer) {
                        scrollContainer.removeEventListener('scroll', handleScroll);
                        scrollContainer.removeEventListener('scroll', updateScrollButtonVisibility);
                    } else {
                        window.removeEventListener('scroll', handleScroll);
                        window.removeEventListener('scroll', updateScrollButtonVisibility);
                    }
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchmove', handleTouchMove);
                    window.removeEventListener('resize', handleResize);
                    
                    // Clear any pending timers
                    if (touchMoveTimer) clearTimeout(touchMoveTimer);
                    if (scrollTimer) clearTimeout(scrollTimer);
                    if (initialMountTimer) clearTimeout(initialMountTimer);
                };
            }, [lastScrollY, isExpanded]); // Removed manuallyHidden to prevent scroll system restart
            
            // Calculate header height for proper content padding
            useEffect(() => {
                const updateContentPadding = (forceUpdate = false) => {
                    const header = document.querySelector('.header-section');
                    const content = document.querySelector('.content-section');
                    const exportMenu = document.querySelector('.export-menu');
                    
                    if (header && content) {
                        // SKIP padding updates when manually hidden - let the manual effect handle it
                        if (manuallyHidden && !forceUpdate) {
                            console.log('⏭️ Skipping padding update - manually hidden');
                            return;
                        }
                        
                        // Temporarily disable transitions for immediate measurement
                        const originalTransition = content.style.transition;
                        if (forceUpdate) {
                            content.style.transition = 'none';
                        }
                        
                        // Force browser to recalculate layout for accurate measurements
                        void header.offsetHeight; // Trigger reflow
                        
                        // Get header height - handle both visible and hidden states
                        let headerHeight;
                        
                        // Check if header is currently visible
                        const isHeaderVisible = header.style.opacity !== '0' && 
                                              header.style.transform !== 'translateY(-100%)' &&
                                              !manuallyHidden;
                        
                        if (isHeaderVisible) {
                            // Header is visible, measure directly
                            headerHeight = header.offsetHeight;
                        } else {
                            // Header is hidden, temporarily show it for measurement
                            const originalDisplay = header.style.display;
                            const originalVisibility = header.style.visibility;
                            const originalOpacity = header.style.opacity;
                            const originalTransform = header.style.transform;
                            
                            header.style.display = 'block';
                            header.style.visibility = 'visible';
                            header.style.opacity = '1';
                            header.style.transform = 'translateY(0)';
                            
                            // Force reflow
                            void header.offsetHeight;
                            
                            // Get the actual height of the header after making it visible
                            headerHeight = header.offsetHeight;
                            
                            // Restore original properties
                            header.style.display = originalDisplay;
                            header.style.visibility = originalVisibility;
                            header.style.opacity = originalOpacity;
                            header.style.transform = originalTransform;
                        }
                        
                        // NEW: Calculate exact position where tasks should start
                        let idealTaskStartPosition = headerHeight;
                        
                        // Add buffer for export menu if it exists and is visible
                        if (exportMenu && window.getComputedStyle(exportMenu).display !== 'none') {
                            const exportMenuHeight = exportMenu.offsetHeight || 50;
                            idealTaskStartPosition += exportMenuHeight + 20; // 20px margin
                        }
                        
                        // Calculate optimal padding to position tasks just below all UI elements
                        const optimalBuffer = 20; // Minimal buffer for clean spacing
                        const finalPadding = idealTaskStartPosition + optimalBuffer;
                        
                        content.style.paddingTop = `${finalPadding}px`;
                        
                        // Add explicit debugging and force the padding with higher specificity
                        content.style.setProperty('padding-top', `${finalPadding}px`, 'important');
                        
                        // Reduce console spam - only log on significant changes
                        const currentState = `${headerHeight}-${finalPadding}-${isHeaderVisible}-${manuallyHidden}`;
                        const lastState = window.lastPaddingState || '';
                        
                        if (currentState !== lastState) {
                            console.log('📐 Content padding updated:', {
                                headerHeight: headerHeight,
                                idealTaskStart: idealTaskStartPosition,
                                finalPadding: finalPadding,
                                headerVisible: isHeaderVisible,
                                manuallyHidden: manuallyHidden,
                                gapReduction: `${80 - optimalBuffer}px saved`,
                                paddingForced: true
                            });
                            
                            // Also verify the padding was actually applied
                            setTimeout(() => {
                                const appliedPadding = window.getComputedStyle(content).paddingTop;
                                console.log('✅ Padding verification:', {
                                    expected: `${finalPadding}px`,
                                    actual: appliedPadding,
                                    success: appliedPadding === `${finalPadding}px`
                                });
                            }, 50);
                            
                            window.lastPaddingState = currentState;
                        }
                        
                        if (forceUpdate) {
                            // Restore original transition after a small delay
                            setTimeout(() => {
                                content.style.transition = originalTransition;
                            }, 50);
                        }
                    }
                };
                
                // Run immediately on mount for faster initial positioning
                updateContentPadding(true); // Force update on mount
                
                // Reduced timer setup to prevent spam - only essential checks
                const immediateTimer = setTimeout(() => updateContentPadding(true), 100);
                const finalTimer = setTimeout(() => updateContentPadding(true), 800);
                
                // And whenever window is resized
                const handleResize = () => updateContentPadding(true);
                window.addEventListener('resize', handleResize);
                
                // Special handler for the expand/collapse of instructions
                let mutationTimer = null;
                const headerObserver = new MutationObserver((mutations) => {
                    // Only trigger on meaningful changes that affect height
                    const significantChange = mutations.some(mutation => {
                        // Check for class changes that affect visibility/state
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            return true;
                        }
                        // Check for structural changes (adding/removing elements)
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            return true;
                        }
                        // Ignore style changes and minor mutations
                        return false;
                    });
                    
                    if (significantChange) {
                        // Debounce mutations to prevent spam
                        if (mutationTimer) clearTimeout(mutationTimer);
                        mutationTimer = setTimeout(() => updateContentPadding(true), 300);
                    }
                });
                
                // Observe changes to the header to catch any dynamic height changes
                if (document.querySelector('.header-section')) {
                    headerObserver.observe(document.querySelector('.header-section'), {
                        attributes: true,
                        attributeFilter: ['class', 'style'], // Only watch class and style changes
                        childList: true, // Watch for adding/removing elements
                        subtree: false, // Don't watch deep children
                        characterData: false // Don't watch text changes
                    });
                }
                
                return () => {
                    clearTimeout(immediateTimer);
                    clearTimeout(finalTimer);
                    if (mutationTimer) clearTimeout(mutationTimer);
                    window.removeEventListener('resize', handleResize);
                    headerObserver.disconnect();
                };
            }, [headerVisible, isExpanded]); // Removed manuallyHidden to prevent constant re-calculation
            
            // Separate effect for manual header visibility changes (prevents full system restart)
            useEffect(() => {
                // Only handle padding adjustments for manual visibility changes
                const header = document.querySelector('.header-section');
                const content = document.querySelector('.content-section');
                const exportMenu = document.querySelector('.export-menu');
                
                if (header && content) {
                    if (manuallyHidden) {
                        // Fixed padding when header is manually hidden
                        content.style.setProperty('padding-top', '40px', 'important');
                        if (exportMenu) {
                            exportMenu.style.top = '50px';
                        }
                        console.log('🔒 Manual hide - padding locked to 40px');
                        
                        // STOP other padding monitors when manually hidden
                        if (window.paddingMonitor) {
                            clearInterval(window.paddingMonitor);
                            window.paddingMonitor = null;
                        }
                    } else {
                        // Recalculate padding when showing again
                        const headerHeight = header.offsetHeight || 194;
                        const optimalBuffer = 20;
                        const finalPadding = headerHeight + optimalBuffer;
                        content.style.setProperty('padding-top', `${finalPadding}px`, 'important');
                        
                        if (exportMenu) {
                            const dynamicTop = headerHeight + 20;
                            exportMenu.style.top = `${dynamicTop}px`;
                        }
                        console.log('🔓 Manual show - padding restored to', finalPadding + 'px');
                    }
                }
            }, [manuallyHidden]); // Only manuallyHidden dependency
            
            // Add initial-load class to body on component mount and remove after initialization
            useEffect(() => {
                // Add the initial-load class to prevent overlap during loading
                document.body.classList.add('initial-load');
                
                // Set proper initial padding immediately
                const content = document.querySelector('.content-section');
                const header = document.querySelector('.header-section');
                if (content && header) {
                    // Force immediate proper padding to prevent overlay - USE OPTIMIZED CALCULATION
                    const headerHeight = header.offsetHeight || 200; // Fallback height
                    
                    // Use the same optimized calculation as everywhere else
                    const exportMenu = document.querySelector('.export-menu');
                    let idealTaskStartPosition = headerHeight;
                    
                    // Add buffer for export menu if it exists and is visible
                    if (exportMenu && window.getComputedStyle(exportMenu).display !== 'none') {
                        const exportMenuHeight = exportMenu.offsetHeight || 50;
                        idealTaskStartPosition += exportMenuHeight + 20; // 20px margin
                    }
                    
                    // Calculate optimal padding with minimal buffer
                    const optimalBuffer = 20; // Same as main function
                    const finalPadding = idealTaskStartPosition + optimalBuffer;
                    
                    content.style.paddingTop = `${finalPadding}px`;
                    console.log('🚀 Initial optimized padding set immediately:', finalPadding + 'px');
                    
                    // Force the padding with higher specificity to override any CSS
                    content.style.setProperty('padding-top', `${finalPadding}px`, 'important');
                    
                    // Add a monitoring system to detect if padding gets reset
                    // Store the monitor reference globally so we can clear old ones
                    if (window.paddingMonitor) {
                        clearInterval(window.paddingMonitor);
                    }
                    
                    window.paddingMonitor = setInterval(() => {
                        const currentPadding = window.getComputedStyle(content).paddingTop;
                        if (currentPadding !== `${finalPadding}px`) {
                            console.warn('🚨 Padding was reset!', {
                                expected: `${finalPadding}px`,
                                current: currentPadding,
                                restoring: true
                            });
                            content.style.setProperty('padding-top', `${finalPadding}px`, 'important');
                        }
                    }, 500);
                    
                    // Clear monitor after 5 seconds and store reference for cleanup
                    setTimeout(() => {
                        if (window.paddingMonitor) {
                            clearInterval(window.paddingMonitor);
                            window.paddingMonitor = null;
                        }
                    }, 5000);
                }
                
                // Remove the initial-load class for faster initialization
                const removeInitialLoadClass = setTimeout(() => {
                    document.body.classList.remove('initial-load');
                    console.log('🎬 Initial load class removed - normal operation started');
                }, 300); // Reduced to 300ms for faster initialization
                
                return () => {
                    clearTimeout(removeInitialLoadClass);
                    document.body.classList.remove('initial-load'); // Clean up
                };
            }, []);
            
            // Effect to update export menu position whenever search term or header state changes
            useEffect(() => {
                const timer = setTimeout(updateExportMenuPosition, 100);
                return () => clearTimeout(timer);
            }, [searchTerm, manuallyHidden, headerVisible]);
            
            // Effect to highlight the instructions button when scrolled down and instructions are hidden
            useEffect(() => {
                // If we've scrolled down and instructions are closed, highlight the button
                const shouldHighlightButton = lastScrollY > 100 && !isExpanded && !manuallyHidden;
                
                // Find the instructions button
                const instructionsButton = document.querySelector('.instructions-toggle-button');
                if (instructionsButton) {
                    if (shouldHighlightButton) {
                        // Add a subtle pulse animation to draw attention, but only briefly
                        // so it doesn't become annoying to the user
                        instructionsButton.style.animation = 'pulseHighlight 2s ease-in-out';
                        instructionsButton.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                        
                        // Remove the animation after a few pulses
                        setTimeout(() => {
                            if (instructionsButton) {
                                instructionsButton.style.animation = '';
                                // Keep a subtle glow
                                instructionsButton.style.boxShadow = '0 0 5px rgba(255, 215, 0, 0.3)';
                            }
                        }, 4000);
                    } else {
                        // Remove animation when not needed
                        instructionsButton.style.animation = '';
                        instructionsButton.style.boxShadow = isExpanded ? 
                            '0 0 8px rgba(255, 215, 0, 0.5)' : 
                            'none';
                    }
                }
            }, [lastScrollY, isExpanded, manuallyHidden]);
            
            // Function to toggle header visibility manually - simplified to prevent React re-mounting
            const toggleHeaderManually = () => {
                console.log("Toggle header button clicked!");
                
                const newHiddenState = !manuallyHidden;
                setManuallyHidden(newHiddenState);
                
                // Let React handle the state change naturally without aggressive DOM manipulation
                // The useEffect hooks will handle the proper updates based on the manuallyHidden state
                
                console.log(`🔄 Header ${newHiddenState ? 'hiding' : 'showing'} - React state updated`);
            };
            
            return (
                <div className="main-layout">
                    {/* Toggle button for header visibility - always visible at top of content */}
                    <button 
                        id="header-toggle-button"
                        className="header-toggle-btn"
                        onClick={() => {
                            console.log("Button clicked directly");
                            toggleHeaderManually();
                        }}
                        onDoubleClick={() => {
                            // Force toggle via double-click - simplified
                            console.log("FORCE TOGGLE via double-click");
                            setManuallyHidden(!manuallyHidden);
                        }}
                        style={{
                            position: 'fixed',
                            top: manuallyHidden ? '5px' : '0',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            background: manuallyHidden 
                                ? 'rgba(255, 215, 0, 0.4)' 
                                : 'rgba(255, 215, 0, 0.2)',
                            border: '1px solid rgba(255, 215, 0, 0.6)',
                            borderRadius: manuallyHidden ? '20px' : '0 0 20px 20px',
                            padding: '8px 16px', // Larger for better visibility
                            fontSize: '13px', // Slightly larger
                            fontWeight: '600',
                            color: '#FFD700',
                            cursor: 'pointer',
                            zIndex: 2001, // Higher than header (2000)
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            boxShadow: '0 2px 6px rgba(0, 0, 0, 0.4)',
                            transition: 'all 0.3s ease',
                            width: 'auto',
                            minWidth: '120px',
                            textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                        }}
                    >
                        {manuallyHidden ? '▲ Suche anzeigen' : '▼ Suche ausblenden'}
                    </button>
                    
                    {/* Smart Header with Filters - Hides on scroll down, Shows on scroll up */}
                    <div 
                        id="react-header-section"
                        className={`header-section ${headerVisible && !manuallyHidden ? 'sticky-visible' : 'header-hidden'}`} 
                        style={{
                            transform: (headerVisible && !manuallyHidden) ? 'translateY(0)' : 'translateY(-100%)',
                            opacity: (headerVisible && !manuallyHidden) ? 1 : 0,
                            pointerEvents: (headerVisible && !manuallyHidden) ? 'auto' : 'none',
                            transition: 'transform 0.3s ease-out, opacity 0.3s ease-out',
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            width: '100%',
                            zIndex: 2000,
                            // Don't use display:none as it causes layout shifts
                            // and prevents smooth animations
                        }}>
                        <div className="filter-container">
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                                <h1 style={{ color: '#FFD700', margin: 0, fontSize: '2rem' }}>
                                    Dienstplan 2025 test
                                </h1>
                                
                                {/* Toggle Button for Instructions */}
                                <button 
                                    className="instructions-toggle-button"
                                    onClick={() => setIsExpanded(!isExpanded)}
                                    style={{
                                        background: isExpanded ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 215, 0, 0.2)',
                                        border: '1px solid rgba(255, 215, 0, 0.5)',
                                        borderRadius: '24px',
                                        padding: '8px 15px',
                                        display: 'flex',
                                        justifyContent: 'center',
                                        alignItems: 'center',
                                        cursor: 'pointer',
                                        transition: 'all 0.2s ease',
                                        color: isExpanded ? '#000' : '#FFD700',
                                        fontWeight: isExpanded ? 'bold' : 'normal',
                                        fontSize: '14px',
                                        marginLeft: '15px',
                                        boxShadow: isExpanded ? '0 0 8px rgba(255, 215, 0, 0.5)' : 'none'
                                    }}
                                    title={isExpanded ? "Anleitung ausblenden" : "Anleitung einblenden"}
                                >
                                    {isExpanded ? '✕ Anleitung' : 'ℹ️ Anleitung'}
                                </button>
                            </div>
                            
                            {/* Collapsible Instructions Box - only shown when button is clicked */}
                            {isExpanded && (
                                <div style={{ 
                                    background: 'rgba(33, 33, 33, 0.9)',
                                    border: '1px solid rgba(255, 215, 0, 0.3)',
                                    borderRadius: '12px',
                                    padding: '15px 20px',
                                    marginBottom: '15px',
                                    fontSize: '14px',
                                    color: '#fff',
                                    animation: 'fadeIn 0.4s ease',
                                    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
                                    maxHeight: '500px',
                                    overflow: 'hidden',
                                    transition: 'all 0.4s ease'
                                }}>
                                    <p style={{ margin: '0 0 5px 0', textAlign: 'center', fontWeight: 'bold' }}>
                                        🔍 So funktioniert die Suche:
                                    </p>
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Gib deinen Namen ein ODER klicke auf deinen Namen in einer Aufgabe, um alle deine Aufgaben zu sehen
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Tag oder Aufgabe filtern über die Dropdown-Menüs
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Klicke erneut auf deinen Namen, um den Filter aufzuheben
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Ergebnisse per WhatsApp an dich selbst oder andere senden
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            PDF erstellen oder Aufgaben ausdrucken
                                        </p>
                                    </div>
                                </div>
                            )}
                            
                            {/* Primary Name Search */}
                            <div className="primary-search">
                                <input
                                    type="text"
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                    placeholder="Nach Namen suchen..."
                                />
                                {/* Clear search button */}
                                {searchTerm && (
                                    <button
                                        className="search-clear-btn"
                                        onClick={() => setSearchTerm('')}
                                        title="Suche löschen"
                                    >
                                        ✕
                                    </button>
                                )}
                            </div>
                            
                            {/* Secondary Filters */}
                            <div className="secondary-filters">
                                {/* Day Filter */}
                                <select 
                                    className="filter-select"
                                    value={selectedDay}
                                    onChange={(e) => setSelectedDay(e.target.value)}
                                >
                                    <option value="">Alle Tage</option>
                                    {sortedDays.map(day => (
                                        <option key={day} value={day}>
                                            {day === 'Freitag' ? 'Freitag, 22. August' : 
                                             day === 'Samstag' ? 'Samstag, 23. August' :
                                             day === 'Sonntag' ? 'Sonntag, 24. August' :
                                             day === 'Montag' ? 'Montag, 25. August' :
                                             day === 'Dienstag' ? 'Dienstag, 26. August' :
                                             day === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                             day}
                                        </option>
                                    ))}
                                </select>
                                
                                {/* Task Search Combo */}
                                <div className="task-search-combo">
                                    <input
                                        type="text"
                                        value={taskSearchTerm}
                                        onChange={handleTaskInputChange}
                                        onFocus={() => setShowTaskDropdown(taskSearchTerm.length > 0)}
                                        onBlur={() => setTimeout(() => setShowTaskDropdown(false), 200)} // Delay to allow click
                                        placeholder="Aufgabe suchen..."
                                    />
                                    
                                    {/* Dropdown arrow */}
                                    <button
                                        className="task-dropdown-btn"
                                        onClick={() => setShowTaskDropdown(!showTaskDropdown)}
                                        title="Aufgaben anzeigen"
                                    >
                                        ▼
                                    </button>
                                    
                                    {/* Clear button */}
                                    {taskSearchTerm && (
                                        <button
                                            className="task-search-clear"
                                            onClick={clearTaskSearch}
                                            title="Suche löschen"
                                        >
                                            ✕
                                        </button>
                                    )}
                                    
                                    {/* Dropdown list */}
                                    {showTaskDropdown && (
                                        <div className="task-dropdown">
                                            {filteredDropdownTasks.length > 0 ? (
                                                filteredDropdownTasks.map((task, index) => (
                                                    <div
                                                        key={index}
                                                        className="task-dropdown-item"
                                                        onClick={() => handleTaskSelect(task)}
                                                    >
                                                        {task}
                                                    </div>
                                                ))
                                            ) : (
                                                <div className="task-dropdown-item" style={{ color: 'rgba(255, 215, 0, 0.6)', cursor: 'default' }}>
                                                    Keine passenden Aufgaben gefunden
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Clear Filters - Always visible for consistent positioning */}
                                <button 
                                    className="nav-btn"
                                    onClick={() => {
                                        setSearchTerm('');
                                        setSelectedDay('');
                                        setSelectedTask('');
                                        clearTaskSearch();
                                    }}
                                    style={{ 
                                        padding: '8px 16px', 
                                        fontSize: '12px',
                                        opacity: (searchTerm || selectedDay || selectedTask || taskSearchTerm) ? 1 : 0.5
                                    }}
                                    disabled={!(searchTerm || selectedDay || selectedTask || taskSearchTerm)}
                                >
                                    {searchTerm ? '👥 Alle anzeigen' : '🔄 Reset'}
                                </button>
                            </div>
                        </div>
                        
                        {/* Results Info - Only show when searching for a person */}
                        {searchTerm && (
                            <div className="export-menu" style={{ 
                                maxWidth: '1200px', 
                                margin: '15px auto 0 auto',
                                padding: '10px 15px',
                                background: 'rgba(40, 167, 69, 0.2)',
                                border: '1px solid rgba(40, 167, 69, 0.4)',
                                borderRadius: '8px',
                                color: '#28a745',
                                textAlign: 'center',
                                fontSize: '14px',
                                zIndex: 1500, /* High enough to appear above content but below header */
                                position: 'relative'
                            }}>
                                <div className="export-buttons" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', flexWrap: 'wrap', gap: '10px' }}>
                                    <span>{filteredTasks.length} Aufgaben gefunden {searchTerm && `für "${searchTerm}"`}</span>
                                    
                                    {/* WhatsApp sharing button */}
                                    <button 
                                        className="nav-btn"
                                        onClick={() => {
                                            // Format tasks as text
                                            const tasksText = filteredTasks
                                                .map(t => `📍 ${t.task}:\n${t.date}, ${t.time}`)
                                                .join('\n\n');
                                            const whatsappText = `Kirmes Aufgaben für ${searchTerm}:\n\n${tasksText}`;
                                            
                                            // Show an info message before opening WhatsApp
                                            alert("Tipp: Du kannst die Nachricht an dich selbst oder an andere Personen senden.\n\nWähle einfach einen Kontakt aus oder nutze die 'An mich selbst senden' Funktion in WhatsApp.");
                                            
                                            // Open WhatsApp with pre-filled message
                                            window.open(`https://wa.me/?text=${encodeURIComponent(whatsappText)}`);
                                        }}
                                        style={{ 
                                            padding: '4px 12px', 
                                            fontSize: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px'
                                        }}
                                        title="An WhatsApp senden - Du kannst die Nachricht auch an dich selbst senden"
                                    >
                                        <span style={{fontSize: '16px'}}>📱</span> Per WhatsApp teilen
                                    </button>
                                    
                                    {/* PDF Export button */}
                                    <button 
                                        className="nav-btn"
                                        onClick={() => {
                                            // Create a temporary div for PDF generation
                                            const pdfContent = document.createElement('div');
                                            pdfContent.innerHTML = `
                                                <div style="font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto;">
                                                    <h1 style="text-align: center; color: #FFD700; margin-bottom: 10px;">Kirmes in Kettig - Dienstplan 2025</h1>
                                                    <h2 style="text-align: center; margin-bottom: 30px;">Aufgaben für ${searchTerm}</h2>
                                                    ${filteredTasks.map((task, idx) => `
                                                        <div style="margin-bottom: 25px; padding: 15px; border: 1px solid #ccc; border-radius: 10px; page-break-inside: avoid;">
                                                            <h3 style="margin-top: 0; color: #FFD700;">📍 ${task.task}</h3>
                                                            <p><strong>📅 Datum:</strong> ${
                                                                task.date === 'Freitag' ? 'Freitag, 22. August' : 
                                                                task.date === 'Samstag' ? 'Samstag, 23. August' :
                                                                task.date === 'Sonntag' ? 'Sonntag, 24. August' :
                                                                task.date === 'Montag' ? 'Montag, 25. August' :
                                                                task.date === 'Dienstag' ? 'Dienstag, 26. August' :
                                                                task.date === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                                                task.date
                                                            }</p>
                                                            <p><strong>🕐 Uhrzeit:</strong> ${task.time}</p>
                                                            <p><strong>👥 Zugewiesene Personen:</strong></p>
                                                            <ul style="padding-left: 20px;">
                                                                ${task.persons.map(person => `
                                                                    <li style="${person.toLowerCase().includes(searchTerm.toLowerCase()) ? 'font-weight: bold;' : ''}">${person} ${person.toLowerCase().includes(searchTerm.toLowerCase()) ? '←' : ''}</li>
                                                                `).join('')}
                                                            </ul>
                                                        </div>
                                                    `).join('')}
                                                    <div style="text-align: center; margin-top: 30px; font-size: 12px; color: #888;">
                                                        Generiert am ${new Date().toLocaleDateString('de-DE')} für ${searchTerm}
                                                    </div>
                                                </div>
                                            `;
                                            
                                            // Generate PDF with proper configuration
                                            const opt = {
                                                margin:       [10, 10],
                                                filename:     `Kirmes_Dienstplan_${searchTerm.replace(/\s+/g, '_')}.pdf`,
                                                image:        { type: 'jpeg', quality: 0.98 },
                                                html2canvas:  { scale: 2, useCORS: true },
                                                jsPDF:        { unit: 'mm', format: 'a4', orientation: 'portrait' }
                                            };
                                            
                                            html2pdf().set(opt).from(pdfContent).save();
                                        }}
                                        style={{ 
                                            padding: '4px 12px', 
                                            fontSize: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px'
                                        }}
                                        title="Als PDF speichern"
                                    >
                                        <span style={{fontSize: '16px'}}>📄</span> Als PDF speichern
                                    </button>
                                    
                                    {/* Print button */}
                                    <button 
                                        className="nav-btn"
                                        onClick={() => {
                                            // Set the current date as a CSS variable before printing
                                            const currentDate = new Date().toLocaleDateString('de-DE');
                                            document.documentElement.style.setProperty('--print-date', `"${currentDate}"`);
                                            
                                            // Set the subtitle with search term
                                            const subtitle = searchTerm 
                                                ? `Aufgaben für: ${searchTerm}` 
                                                : `Alle Aufgaben`;
                                            
                                            // Create a more detailed subtitle when printing for a specific person
                                            if (searchTerm) {
                                                const taskCount = filteredTasks.length;
                                                const taskText = taskCount === 1 ? "Aufgabe" : "Aufgaben";
                                                // Create subtitle showing "Aufgaben für [Person Name]" as in the PDF screenshot
                                                const subtitle = `Aufgaben für ${searchTerm}`;
                                                document.documentElement.style.setProperty('--print-subtitle', `"${subtitle}"`);
                                                
                                                // Set personalized footer
                                                let personalizedFooter = `Vielen Dank für deine Unterstützung bei der Kirmes in Kettig 2025, ${searchTerm}!`;
                                                document.documentElement.style.setProperty('--print-footer', `"${personalizedFooter}"`);
                                            } else {
                                                const allTasksSubtitle = `Alle Aufgaben (${filteredTasks.length})`;
                                                document.documentElement.style.setProperty('--print-subtitle', `"${allTasksSubtitle}"`);
                                                const footerText = `Ausgedruckt am ${currentDate}`;
                                                document.documentElement.style.setProperty('--print-footer', `"${footerText}"`);
                                            }
                                            
                                            // Add date below the footer for all prints
                                            const dateDiv = document.createElement('div');
                                            dateDiv.style.position = 'fixed';
                                            dateDiv.style.bottom = '5mm';
                                            dateDiv.style.right = '10mm';
                                            dateDiv.style.fontSize = '8pt';
                                            dateDiv.style.color = '#999';
                                            dateDiv.style.zIndex = '9999';
                                            dateDiv.style.fontStyle = 'italic';
                                            dateDiv.innerHTML = `Ausgedruckt am ${currentDate}`;
                                            document.body.appendChild(dateDiv);
                                            
                                            // Remove the date div after printing
                                            setTimeout(() => {
                                                document.body.removeChild(dateDiv);
                                            }, 1000);
                                            
                                            // Optimize the layout for single-page printing by temporarily 
                                            // modifying some style properties
                                            const contentDiv = document.querySelector('.content-section > div');
                                            const taskCards = document.querySelectorAll('.task-card');
                                            
                                            // Store original styles to restore after printing
                                            const originalStyles = {
                                                contentMargin: contentDiv.style.margin,
                                                taskCardMargin: Array.from(taskCards).map(card => card.style.marginBottom)
                                            };
                                            
                                            // Apply tight layout if there are only a few tasks
                                            if (filteredTasks.length <= 5) {
                                                taskCards.forEach(card => {
                                                    card.style.marginBottom = '4px';
                                                    card.style.padding = '5px';
                                                });
                                            }
                                            
                                            // Trigger print dialog immediately
                                            window.print();
                                            
                                            // Restore original styles after printing
                                            setTimeout(() => {
                                                contentDiv.style.margin = originalStyles.contentMargin;
                                                taskCards.forEach((card, index) => {
                                                    card.style.marginBottom = originalStyles.taskCardMargin[index];
                                                });
                                            }, 1000);
                                        }}
                                        style={{ 
                                            padding: '4px 12px', 
                                            fontSize: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px'
                                        }}
                                        title="Aufgaben drucken"
                                    >
                                        <span style={{fontSize: '16px'}}>🖨️</span> Drucken
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Scrollable Content */}
                    <div className="content-section">
                        <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                            {filteredTasks.map((task, index) => (
                                <div key={index} className="task-card" style={{
                                    background: 'rgba(255, 255, 255, 0.08)',
                                    borderRadius: '12px',
                                    padding: '20px',
                                    marginBottom: '15px',
                                    border: '1px solid rgba(255, 215, 0, 0.15)',
                                    transition: 'all 0.3s ease'
                                }}>
                                    <div style={{
                                        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
                                        paddingBottom: '10px',
                                        marginBottom: '10px'
                                    }}>
                                        <div className="task-header" style={{
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'flex-start',
                                            gap: '15px',
                                            flexWrap: 'wrap'
                                        }}>
                                            <div style={{ flex: 1 }}>
                                                <h3 className="task-title" style={{ 
                                                    color: '#FFD700', 
                                                    fontSize: '1.3rem', 
                                                    fontWeight: '600',
                                                    margin: '0 0 8px 0'
                                                }}>
                                                    📍 {task.task}
                                                </h3>
                                            </div>
                                            
                                            <div className="task-date-time" style={{
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'flex-end',
                                                gap: '4px',
                                                textAlign: 'right'
                                            }}>
                                                <span style={{
                                                    color: 'rgba(255, 255, 255, 0.9)',
                                                    fontSize: '1rem',
                                                    fontWeight: '600'
                                                }}>
                                                    📅 {task.date === 'Freitag' ? 'Freitag, 22. August' : 
                                                         task.date === 'Samstag' ? 'Samstag, 23. August' :
                                                         task.date === 'Sonntag' ? 'Sonntag, 24. August' :
                                                         task.date === 'Montag' ? 'Montag, 25. August' :
                                                         task.date === 'Dienstag' ? 'Dienstag, 26. August' :
                                                         task.date === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                                         task.date}
                                                </span>
                                                <span style={{
                                                    color: 'rgba(255, 255, 255, 0.8)',
                                                    fontSize: '0.95rem'
                                                }}>
                                                    🕐 {task.time}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <h4 style={{ 
                                            color: 'rgba(255, 255, 255, 0.9)', 
                                            fontSize: '1rem',
                                            marginBottom: '10px',
                                            fontWeight: '500'
                                        }}>
                                            👥 Zugewiesene Personen ({task.persons.length}):
                                        </h4>
                                        <div style={{
                                            display: 'flex',
                                            flexWrap: 'wrap',
                                            gap: '8px'
                                        }}>
                                            {task.persons.length > 0 ? (
                                                task.persons.map((person, personIndex) => (
                                                    <span 
                                                        key={personIndex} 
                                                        className={`person-tag ${searchTerm && person.toLowerCase() === searchTerm.toLowerCase() ? 'selected' : ''}`}
                                                        onClick={(e) => {
                                                            // Add click feedback animation
                                                            const target = e.currentTarget;
                                                            
                                                            // Apply a quick pulse effect
                                                            target.style.transform = 'scale(0.95)';
                                                            setTimeout(() => {
                                                                target.style.transform = 'scale(1.05)';
                                                                setTimeout(() => {
                                                                    target.style.transform = '';
                                                                }, 150);
                                                            }, 150);
                                                            
                                                            // Toggle behavior: if already filtered by this person, clear the filter
                                                            // Otherwise, set this person as the filter
                                                            if (searchTerm && person.toLowerCase() === searchTerm.toLowerCase()) {
                                                                setSearchTerm(''); // Clear the filter
                                                                
                                                                // Visual feedback for clearing filter
                                                                target.animate([
                                                                    { backgroundColor: 'rgba(255, 215, 0, 0.3)', opacity: 1 },
                                                                    { backgroundColor: 'rgba(255, 255, 255, 0.15)', opacity: 0.8 }
                                                                ], { duration: 300, fill: 'forwards' });
                                                                
                                                                // Force update content padding after filter change with debug info
                                                                setTimeout(() => forceUpdateContentPadding(true), 100);
                                                                setTimeout(() => forceUpdateContentPadding(true), 300);
                                                                // Final check with longer delay
                                                                setTimeout(() => forceUpdateContentPadding(false), 800);
                                                            } else {
                                                                setSearchTerm(person); // Set the filter
                                                                
                                                                // Visual feedback for setting filter - ripple effect
                                                                const ripple = document.createElement('span');
                                                                ripple.style.position = 'absolute';
                                                                ripple.style.borderRadius = '50%';
                                                                ripple.style.backgroundColor = 'rgba(255, 215, 0, 0.3)';
                                                                ripple.style.transform = 'scale(0)';
                                                                ripple.style.animation = 'ripple 0.6s linear';
                                                                ripple.style.opacity = '1';
                                                                
                                                                // Position the ripple at click point
                                                                const rect = target.getBoundingClientRect();
                                                                ripple.style.width = ripple.style.height = Math.max(rect.width, rect.height) + 'px';
                                                                ripple.style.left = e.clientX - rect.left - (parseInt(ripple.style.width) / 2) + 'px';
                                                                ripple.style.top = e.clientY - rect.top - (parseInt(ripple.style.height) / 2) + 'px';
                                                                
                                                                target.appendChild(ripple);
                                                                
                                                                // Clean up ripple element after animation
                                                                setTimeout(() => {
                                                                    if (ripple && ripple.parentNode === target) {
                                                                        target.removeChild(ripple);
                                                                    }
                                                                }, 600);
                                                                
                                                                // Force update content padding after filter change with debug info
                                                                setTimeout(() => forceUpdateContentPadding(true), 100);
                                                                setTimeout(() => forceUpdateContentPadding(true), 300);
                                                                // Final check with longer delay
                                                                setTimeout(() => forceUpdateContentPadding(false), 800);
                                                            }
                                                        }}
                                                        style={{
                                                            position: 'relative', // For ripple effect
                                                            overflow: 'hidden', // For ripple effect
                                                            background: searchTerm && person.toLowerCase().includes(searchTerm.toLowerCase())
                                                                ? 'rgba(255, 215, 0, 0.3)' // Highlight searched person
                                                                : 'rgba(255, 255, 255, 0.15)',
                                                            color: searchTerm && person.toLowerCase().includes(searchTerm.toLowerCase())
                                                                ? '#000'
                                                                : '#fff',
                                                            padding: '6px 12px',
                                                            borderRadius: '20px',
                                                            fontSize: '14px',
                                                            fontWeight: '500',
                                                            border: searchTerm && person.toLowerCase().includes(searchTerm.toLowerCase())
                                                                ? '1px solid rgba(255, 215, 0, 0.6)'
                                                                : '1px solid rgba(255, 255, 255, 0.2)',
                                                            cursor: 'pointer',
                                                            transition: 'all 0.2s ease',
                                                            userSelect: 'none', // Prevent text selection when double-clicking
                                                            WebkitTapHighlightColor: 'transparent' // Remove default mobile tap highlight
                                                        }}
                                                        onMouseOver={(e) => {
                                                            // Only apply hover effects if not already selected
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.transform = 'translateY(-2px)';
                                                                e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 215, 0, 0.2)';
                                                            }
                                                        }}
                                                        onMouseOut={(e) => {
                                                            // Only reset hover effects if not already selected
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.transform = 'translateY(0)';
                                                                e.currentTarget.style.boxShadow = 'none';
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
                                                            }
                                                        }}
                                                        onTouchStart={(e) => {
                                                            // Touch feedback - instantly apply a subtle effect
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 215, 0, 0.15)';
                                                                e.currentTarget.style.transform = 'scale(0.98)';
                                                            }
                                                        }}
                                                        onTouchEnd={(e) => {
                                                            // Reset touch effect unless this is now selected
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
                                                                e.currentTarget.style.transform = '';
                                                            }
                                                        }}
                                                        title={searchTerm && person.toLowerCase() === searchTerm.toLowerCase() 
                                                            ? `Filter für "${person}" aufheben` 
                                                            : `Nach "${person}" filtern`}
                                                    >
                                                        {person}
                                                        {searchTerm && person.toLowerCase() === searchTerm.toLowerCase() && (
                                                            <span style={{ marginLeft: '5px', fontSize: '10px', opacity: 0.7 }}>✕</span>
                                                        )}
                                                    </span>
                                                ))
                                            ) : (
                                                <span style={{
                                                    color: 'rgba(255, 255, 255, 0.5)',
                                                    fontStyle: 'italic',
                                                    fontSize: '14px'
                                                }}>
                                                    Noch keine Personen zugewiesen
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            ))}
                            
                            {/* Show message when no tasks match the filters */}
                            {filteredTasks.length === 0 && (
                                <div style={{
                                    textAlign: 'center',
                                    padding: '30px 20px',
                                    background: 'rgba(0, 0, 0, 0.2)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(255, 215, 0, 0.2)',
                                }}>
                                    <div style={{ fontSize: '36px', marginBottom: '10px' }}>🔍</div>
                                    <h3 style={{ color: '#FFD700', marginBottom: '10px' }}>Keine passenden Aufgaben gefunden</h3>
                                    <p style={{ color: '#ccc' }}>Bitte versuche es mit anderen Suchkriterien.</p>
                                    <button 
                                        onClick={() => {
                                            setSearchTerm('');
                                            setSelectedDay('');
                                            setSelectedTask('');
                                            setTaskSearchTerm('');
                                        }}
                                        style={{
                                            background: 'rgba(255, 215, 0, 0.2)',
                                            border: '1px solid rgba(255, 215, 0, 0.4)',
                                            borderRadius: '20px',
                                            padding: '8px 15px',
                                            marginTop: '15px',
                                            color: '#FFD700',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        Filter zurücksetzen
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* Scroll to top button - always visible after scrolling a bit */}
                    <button 
                        id="scrollTopButton"
                        onClick={() => {
                            // Get the actual scroll container
                            const scrollContainer = document.querySelector('.content-section');
                            
                            if (scrollContainer) {
                                // Force scroll to top using the container's scroll methods
                                scrollContainer.scrollTo({ top: 0, behavior: 'smooth' });
                                scrollContainer.scrollTop = 0;
                                
                                console.log('📜 Scrolling container to top, container scrollTop:', scrollContainer.scrollTop);
                            } else {
                                // Fallback to window scroll if container not found
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                                document.documentElement.scrollTop = 0;
                                document.body.scrollTop = 0;
                            }
                            
                            // Show the search header when scrolling to top
                            if (manuallyHidden) {
                                toggleHeaderManually();
                            }
                            
                            // Additional force scroll after a small delay
                            setTimeout(() => {
                                if (scrollContainer) {
                                    scrollContainer.scrollTo(0, 0);
                                    scrollContainer.scrollTop = 0;
                                } else {
                                    window.scrollTo(0, 0);
                                    document.documentElement.scrollTop = 0;
                                    document.body.scrollTop = 0;
                                }
                            }, 100);
                        }}
                        style={{
                            position: 'fixed',
                            bottom: '20px',
                            right: '20px',
                            width: '48px',
                            height: '48px',
                            borderRadius: '50%',
                            backgroundColor: 'rgba(255, 215, 0, 0.9)',
                            color: '#000',
                            border: 'none',
                            display: 'flex',
                            opacity: '1', /* Always visible */
                            pointerEvents: 'auto', /* Always interactive */
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '24px',
                            cursor: 'pointer',
                            zIndex: 9999, /* Increased z-index to ensure visibility */
                            boxShadow: '0 4px 15px rgba(0, 0, 0, 0.5)',
                            transition: 'opacity 0.3s ease, transform 0.3s ease',
                            fontWeight: 'bold',
                            transform: 'scale(1)' /* Always full size */
                        }}
                        title="Nach oben"
                    >
                        ↑
                    </button>
                </div>
            );
        }, (prevProps, nextProps) => {
            // Only re-render if tasks array content actually changed
            const tasksChanged = prevProps.tasks.length !== nextProps.tasks.length ||
                                prevProps.tasks !== nextProps.tasks;
            
            if (!tasksChanged) {
                console.log('🚫 React.memo: Preventing re-render - tasks unchanged');
            } else {
                console.log('✅ React.memo: Allowing re-render - tasks changed');
            }
            
            return !tasksChanged; // Return true to PREVENT re-render, false to ALLOW
        });
        
        // Main App Component - Simplified
        const App = () => {
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            const [tasks, setTasks] = useState([]);
            const [error, setError] = useState('');
            
            // Debug: Log when App component renders
            console.log("🏠 App component rendering - logged in:", isLoggedIn, "tasks count:", tasks.length);
            
            // Load data from CSV file on component mount
            useEffect(() => {
                // Clear any existing cache first
                if ('caches' in window) {
                    caches.keys().then(function(names) {
                        for (let name of names) caches.delete(name);
                    });
                }
                
                // Load CSV data
                loadCSVFromFile();
            }, []);
            
            const loadCSVFromFile = async () => {
                try {
                    // Force cache clear with multiple cache-busting techniques
                    const timestamp = Date.now() + Math.random();
                    const response = await fetch(`real-data.csv?t=${timestamp}&cb=${Math.random()}`, {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    if (response.ok) {
                        const csvText = await response.text();
                        const processedTasks = await processCSV(csvText);
                        setTasks(processedTasks);
                        return;
                    }
                } catch (error) {
                    // Silently handle error
                }
                
                // No fallback data - if CSV fails to load, show empty state
                setTasks([]);
            };
            
            const handleLogin = () => {
                // Complete cache clearing
                localStorage.clear();
                sessionStorage.clear();
                
                // Clear any cached fetch requests
                if ('caches' in window) {
                    caches.keys().then(function(names) {
                        for (let name of names) caches.delete(name);
                    });
                }
                

                setIsLoggedIn(true);
                setError('');
                
                // Force reload fresh CSV data with delay to ensure cache is cleared
                setTimeout(() => {
                    loadCSVFromFile();
                }, 100);
            };
            
            const handleWrongPassword = () => {
                setError('Falsches Passwort. Bitte versuchen Sie es erneut.');
            };
            
            // Memoize tasks to prevent unnecessary re-renders (MUST be before conditional return)
            const memoizedTasks = React.useMemo(() => {
                console.log('🔄 Memoizing tasks array, length:', tasks.length);
                return tasks;
            }, [tasks.length]); // Only re-memoize if tasks count changes, not the array reference
            
            if (!isLoggedIn) {
                return <LoginPage onLogin={handleLogin} onWrongPassword={handleWrongPassword} error={error} />;
            }
            
            return (
                <TaskViewer 
                    tasks={memoizedTasks} 
                />
            );
        };
        
        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>

    <!-- Smart Header Controller JavaScript -->


    <!-- Removed external smart-header.js script - using inline header control in React component -->


    <!-- Hamburger Menu Implementation has been removed -->
    
</body>
</html>



