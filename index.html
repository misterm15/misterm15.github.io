<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kirmes in Kettig - Dienstplan 2025</title>
    
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- React CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Papa Parse for CSV processing -->
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    
    <!-- html2pdf for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    
    <style>
        /* Print styles */
        @media print {
            body, html {
                height: auto !important;
                overflow: visible !important;
                font-family: Arial, sans-serif !important;
                background: white !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            body * { 
                visibility: hidden; 
                background-color: white !important;
                color: black !important;
            }
            
            .content-section, .content-section * { 
                visibility: visible; 
                color: black !important;
            }
            
            .content-section { 
                position: relative !important; /* Changed from absolute to relative */
                left: 0; 
                top: 0; 
                width: 100%; 
                background-color: white !important;
                height: auto !important;
                overflow: visible !important;
                padding: 0 !important;
                margin: 0 !important;
                font-family: Arial, sans-serif !important;
                float: none !important;
                display: block !important;
            }
            
            /* Compact PDF-like layout for print */
            .content-section > div {
                max-width: 100% !important;
                padding: 0 !important;
                margin: 0 !important;
                /* Reduce spacing at the top of the content - more aggressively */
                margin-top: -30px !important;
            }
            
            .task-card {
                break-inside: avoid !important;
                page-break-inside: avoid !important;
                border: 1px solid #ccc !important;
                margin-bottom: 5px !important; /* Reduced from 8px */
                margin-top: 0 !important;
                background-color: white !important;
                box-shadow: none !important;
                padding: 6px !important; /* Reduced from 8px */
                font-size: 10pt !important; /* Reduced from 11pt */
            }
            
            /* Optimize spacing */
            .task-header {
                margin-bottom: 3px !important; /* Reduced from 5px */
            }
            
            .task-title {
                color: #333 !important;
                font-weight: bold !important;
                border-bottom: 1px solid #ddd !important;
                font-size: 11pt !important; /* Reduced from 12pt */
                margin: 0 0 3px 0 !important; /* Reduced from 5px */
            }
            
            .task-date-time {
                font-size: 9pt !important; /* Reduced from 10pt */
            }
            
            .task-date-time span {
                margin: 0 !important;
                padding: 0 !important;
                line-height: 1.1 !important; /* Reduced from 1.2 */
            }
            
            /* Make task cards take up less vertical space */
            .task-card h4 {
                font-size: 9pt !important; /* Reduced size */
                margin: 3px 0 !important; /* Reduced margins */
            }
            
            /* Person tags */
            .person-tag {
                display: inline !important;
                background: none !important;
                border: none !important;
                padding: 0 !important;
                margin-right: 10px !important;
                font-size: 10pt !important;
            }
            
            /* All task persons in a single line to save space */
            div > div:last-child > div {
                display: block !important;
            }
            
            h4 {
                font-size: 10pt !important;
                margin: 5px 0 !important;
            }
            
            /* Highlighted person */
            .person-tag[style*="searchTerm"] {
                font-weight: bold !important;
            }
            
            /* Page settings */
            @page { 
                size: portrait; 
                margin: 1.0cm !important; /* Reduced margins to fit more content */
            }
            
            /* Remove any float or overflow issues that might cause extra pages */
            * {
                float: none !important;
                position: static !important;
                overflow: visible !important;
            }
            
            .header-section,
            .search-clear-btn,
            .nav-btn,
            .filter-container,
            .secondary-filters,
            .print-hide {
                display: none !important;
            }
            
            /* PDF-style header for print */
            .content-section::before {
                content: "Kirmes in Kettig - Dienstplan 2025";
                font-size: 16pt !important;
                font-weight: bold !important;
                display: block !important;
                text-align: center !important;
                margin-bottom: 2px !important; /* Reduced from 5px */
                color: black !important;
            }
            
            /* Add subtitle with person's name after the title */
            .content-section::after {
                content: var(--print-subtitle);
                font-size: 14pt !important;
                display: block !important;
                text-align: center !important;
                margin-bottom: 5px !important; /* Reduced from 15px */
                color: #000 !important;
                margin-top: 2px !important; /* Reduced from 5px */
            }
            
            /* Compact person listing */
            .content-section .task-card h4 + div {
                display: block !important;
                margin-bottom: 5px !important;
                font-size: 10pt !important;
            }
            
            /* Style for arrow and highlighting person name */
            .content-section .task-card .person-tag[style*="searchTerm"] {
                font-weight: bold !important;
                background-color: #ffeb99 !important; /* Light yellow background */
                padding: 1px 3px !important;
                border-radius: 3px !important;
                color: #000 !important;
            }
            
            .content-section .task-card .person-tag[style*="searchTerm"]::after {
                content: " ←";
                font-weight: bold !important;
            }
            
            /* Add print header as a regular element instead of pseudo-element */
            .content-section {
                position: relative !important;
            }
            
            .content-section::before {
                content: "Kirmes in Kettig - Dienstplan 2025";
                display: block !important;
                position: static !important; /* Changed from fixed to static */
                width: 100% !important;
                text-align: center !important;
                font-size: 16pt !important;
                font-weight: bold !important;
                margin-bottom: 5px !important;
                padding-top: 5mm !important;
                background: white !important;
                border-bottom: 2px solid #ff0000 !important; /* Red line under title */
                padding-bottom: 2px !important;
            }
            
            /* Add subtitle with search term below header */
            .content-section > div::before {
                content: var(--print-subtitle);
                display: block !important;
                position: static !important; /* Ensure position is static */
                text-align: center !important;
                font-size: 14pt !important;
                font-weight: bold !important; /* Make the person name bold */
                margin-bottom: 2px !important; /* Drastically reduced */
                color: #000 !important; /* Darker color to match PDF */
                border-bottom: 1px dotted #ccc !important;
                padding-bottom: 2px !important; /* Drastically reduced */
            }
            
            /* Footer with date and personalized message */
            .content-section > div::after {
                content: var(--print-footer);
                display: block !important;
                position: static !important; /* Ensure position is static */
                text-align: center !important;
                font-size: 9pt !important;
                margin-top: 10px !important;
                color: #666 !important;
                border-top: 0 !important; /* Remove border */
                padding-top: 10px !important;
                white-space: pre !important; /* Preserve newlines in content */
                line-height: 1.4 !important;
                font-style: italic !important;
            }
            
            /* Make the task cards more compact */
            .task-card {
                margin-bottom: 5mm !important;
                border-radius: 5px !important;
            }
            
            /* Make the task title more compact */
            .task-card div:first-child {
                padding-bottom: 5px !important;
                margin-bottom: 5px !important;
            }
            
            /* Position elements better */
            .task-header {
                align-items: center !important;
            }
            
            /* More compact spacing on persons list */
            .task-card h4 {
                margin-top: 0 !important;
            }
            
            /* Allow the subtitle to show by NOT removing the ::after element */
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #0a0a0a 100%);
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        
        /* Animation keyframes */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Ripple effect animation for person tags */
        @keyframes ripple {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                opacity: 0.8;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
        
        /* Pulse animation for selected person tags */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 215, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 215, 0, 0);
            }
        }
        
        /* Main layout for task viewer */
        .main-layout {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding-top: 0; /* Let the content-section handle spacing */
            position: relative;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Force any fixed position elements to stay in place during transitions */
        body {
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        
        /* Additional class to force content below header - adjusted gap */
        .force-content-below-header .content-section {
            margin-top: 320px !important; /* Slightly increased to avoid overlap */
            /* Use consistent padding from variables */
            padding-top: calc(var(--header-height, 200px) + var(--standard-buffer, 15px)) !important;
            position: relative;
            z-index: 1000; /* Below header but above other content */
        }
        
        /* Style to apply on initial page load to prevent overlap before JS runs */
        .initial-load .content-section {
            /* Use consistent padding from variables */
            padding-top: calc(var(--header-height, 200px) + var(--standard-buffer, 15px)) !important;
            margin-top: 10px !important; /* Small margin during initial load */
            transition: padding-top 0.5s ease-in-out, margin-top 0.5s ease-in-out; /* Faster transition for better user experience */
            position: relative;
            z-index: 1000; /* Below header but above other content */
        }
        
        /* Sticky header with filters */
        .header-section {
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 2000; /* Even higher z-index to absolutely ensure header stays above everything */
            padding: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease, visibility 0.3s ease;
            will-change: transform, opacity, visibility;
            /* Force hardware acceleration for smoother transitions */
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }
        
        /* Special styling for header when sticked to top and visible */
        .header-section.sticky-visible {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Scrollable content area */
        .content-section {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-top: 300px; /* Increased initial safe padding - will be adjusted by JavaScript */
            margin-top: 0; /* Ensure no extra margin */
            position: relative;
            z-index: 1; /* Ensure content stays BELOW header */
            /* Padding-top will be set dynamically by JavaScript */
            transition: padding-top 0.3s ease; /* Smooth transitions for padding changes */
            will-change: padding-top; /* Optimize for animation */
            box-sizing: border-box; /* Include padding in height calculation */
        }
        
        /* Ensure task cards have proper spacing and never overlay header */
        .task-card {
            margin-bottom: 20px;
            position: relative;
            z-index: 1; /* Ensure task cards stack below the header */
            transition: transform 0.3s ease; /* Smooth animation when recalculating positions */
            /* Additional styling to ensure cards stand out */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        /* Force header to always be above content */
        .header-section.sticky-visible {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            z-index: 2000 !important;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3) !important;
        }
        
        /* Export menu styling - ensure it's always visible and properly positioned */
        .export-menu {
            position: sticky !important;
            top: 390px !important; /* Position it just below the header - increased to match new spacing */
            z-index: 1500 !important;
            transition: all 0.3s ease !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2) !important;
            margin-bottom: 20px !important; /* Add some space below the export menu */
        }
        
        /* When header is hidden, adjust position accordingly */
        body.force-content-below-header .export-menu {
            top: 390px !important; /* Increased to match new spacing */
            margin-top: 20px !important; /* Add space from top of content */
        }
        
        /* Handle initial page load state for export menu */
        .initial-load .export-menu {
            top: 320px !important; /* Lower initial position to match the screenshot */
            position: relative !important; /* Start as relative to ensure proper placement */
            z-index: 1600 !important; /* Slightly higher z-index during initial load */
        }
        
        /* When header is manually hidden, adjust position for export menu */
        .manually-hidden-header .export-menu {
            top: 50px !important;
        }
        
        /* Ensure export buttons have proper visibility */
        .export-buttons {
            gap: 8px !important;
        }
        
        /* Header toggle button */
        .header-toggle-btn {
            transition: all 0.2s ease;
        }
        
        .header-toggle-btn:hover {
            background: rgba(255, 215, 0, 0.3) !important;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        .header-toggle-btn:active {
            transform: translateX(-50%) translateY(1px) !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3) !important;
        }
        
        /* Filter container */
        .filter-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        
        /* Animation for the collapsible instruction box */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes pulseHighlight {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
            40% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); }
            60% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.7); }
            100% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); }
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .filter-container {
                padding: 10px;
            }
            
            .filter-container h1 {
                font-size: 1.5rem !important;
                margin: 0 !important;
            }
            
            .filter-container p {
                font-size: 0.9rem !important;
                margin: 3px 0 0 0 !important;
            }
            
            .primary-search {
                margin: 15px auto !important;
            }
            
            .primary-search input {
                padding: 15px 40px 15px 15px !important;
                font-size: 16px !important;
            }
            
            .secondary-filters {
                gap: 8px !important;
                margin-top: 10px !important;
            }
            
            .filter-select {
                padding: 8px 10px !important;
                font-size: 12px !important;
                min-width: 90px !important;
            }
            
            .nav-btn {
                padding: 6px 12px !important;
                font-size: 11px !important;
            }
            
            /* Mobile task cards */
            .content-section {
                padding: 10px !important;
                /* Add margin at top to account for the header sliding out */
                padding-top: 15px !important;
            }
            
            .task-card {
                padding: 15px !important;
                margin-bottom: 10px !important;
            }
            
            .task-title {
                font-size: 1.1rem !important;
            }
            
            .task-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 10px !important;
            }
            
            .task-date-time {
                align-items: flex-start !important;
                text-align: left !important;
            }
            
            .task-info {
                flex-direction: column !important;
                gap: 8px !important;
                align-items: flex-start !important;
            }
            
            .task-info span {
                font-size: 0.9rem !important;
            }
            
            .person-tag {
                font-size: 12px !important;
                padding: 4px 8px !important;
            }
            
            /* Selected person tag styles */
            .person-tag.selected {
                background: rgba(255, 215, 0, 0.4) !important;
                border: 1px solid rgba(255, 215, 0, 0.8) !important;
                color: #000 !important;
                box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3) !important;
                animation: pulseHighlight 0.4s ease, pulse 1.5s infinite !important;
                font-weight: 600 !important;
                transform: translateY(-2px) !important;
            }
            
            /* Improved mobile header appearance */
            .header-section {
                padding: 10px 5px !important;
                transition: transform 0.3s ease, opacity 0.3s ease !important;
                will-change: transform, opacity;
                position: fixed !important;
                width: 100% !important;
                top: 0 !important;
                left: 0 !important;
                z-index: 1000 !important;
            }
            
            /* Content section handles its own padding on mobile */
            .main-layout {
                padding-top: 0 !important; /* Let the content section handle spacing */
            }
            
            /* Content section on mobile - dynamic padding handled by JS */
            .content-section {
                position: relative !important;
                z-index: 5 !important; /* Below header but above other elements */
                /* Base padding to be dynamically adjusted by JS */
            }
            
            /* Instructions on mobile */
            .header-section button {
                min-width: 36px !important;
                min-height: 36px !important;
            }
            
            /* Header hiding - simplified for better performance */
            .header-section.header-hidden {
                /* Use transform for smoother animations - this property is GPU accelerated */
                transform: translateY(-100%) !important;
                /* Make it completely invisible */
                opacity: 0 !important;
                /* Prevent interaction with hidden element */
                pointer-events: none !important;
                /* Accessibility & SEO considerations */
                visibility: hidden !important;
                /* For older browsers & complete hiding */
                position: absolute !important;
                top: -9999px !important;
            }
            
            /* Visible header */
            .header-section {
                transform: translateY(0);
                opacity: 1;
                pointer-events: auto;
                visibility: visible;
                position: fixed !important;
                transition: transform 0.3s ease, opacity 0.2s ease;
            }
            
            /* Mobile search bar improvements */
            .primary-search input:focus {
                outline: none;
                border-color: #FFD700;
                background: rgba(0, 0, 0, 0.4);
                box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
            }
            
            /* Super small screens */
            @media (max-width: 380px) {
                .filter-container h1 {
                    font-size: 1.2rem !important;
                }
                
                .primary-search input {
                    font-size: 14px !important;
                    padding: 10px 40px 10px 12px !important;
                }
                
                /* Vertical alignment for filter controls */
                .filter-controls {
                    flex-direction: column !important;
                    align-items: stretch !important;
                    width: 100% !important;
                }
                
                .filter-select, .task-search input {
                    width: 100% !important;
                }
                
                .task-search {
                    width: 100% !important;
                }
                
                /* Compact secondary filters */
                .secondary-filters {
                    flex-direction: column !important;
                    align-items: stretch !important;
                }
                
                .filter-select, .task-search-combo {
                    width: 100% !important;
                    margin-bottom: 8px !important;
                }
                
                .nav-btn {
                    align-self: center !important;
                }
            }
            
            /* Special styling for active search on mobile */
            @media (max-width: 480px) {
                .primary-search:focus-within {
                    position: relative;
                    z-index: 200;
                }
                
                .primary-search:focus-within input {
                    box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3);
                }
            }
        }
        
        /* Primary search (name) */
        .primary-search {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            position: relative;
        }
        
        .primary-search input {
            width: 100%;
            padding: 20px 50px 20px 20px; /* Add right padding for X button */
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #FFD700;
            font-size: 18px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .primary-search input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        /* Search input optimizations for mobile */
        @media (max-width: 480px) {
            .primary-search input {
                padding: 12px 30px 12px 12px;
                font-size: 16px;
                text-align: left;
            }
        }
        
        .primary-search input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
        }
        
        /* Clear button inside search field */
        .search-clear-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 215, 0, 0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }
        
        .search-clear-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        
        /* Secondary filters */
        .secondary-filters {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        /* Responsive adjustments for secondary filters */
        @media (max-width: 480px) {
            .secondary-filters {
                gap: 8px;
                margin-top: 10px;
            }
            
            .filter-select, .task-search-combo {
                flex: 1;
                min-width: 0;
            }
            
            /* Make buttons more tap-friendly on mobile */
            .nav-btn, 
            .search-clear-btn,
            .task-dropdown-btn,
            .task-search-clear {
                min-width: 36px;
                min-height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* Filter controls */
        .filter-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .filter-select, .filter-input {
            padding: 10px 14px;
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.25);
            color: #FFD700;
            font-size: 13px;
            min-width: 110px;
        }
        
        .filter-select:focus, .filter-input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15);
        }
        
        .filter-select option {
            background: #1a1a1a;
            color: #FFD700;
        }
        
        /* Task search combo input */
        .task-search-combo {
            position: relative;
            min-width: 200px;
        }
        
        .task-search-combo input {
            width: 100%;
            padding: 10px 50px 10px 14px; /* More space for dropdown arrow and clear button */
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.25);
            color: #FFD700;
            font-size: 13px;
        }
        
        .task-search-combo input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        .task-search-combo input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15);
        }
        
        .task-dropdown-btn {
            position: absolute;
            right: 28px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 215, 0, 0.7);
            font-size: 12px;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            transition: all 0.2s ease;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .task-dropdown-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        
        .task-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 2px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .task-dropdown-item {
            padding: 8px 12px;
            color: #FFD700;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.1);
        }
        
        .task-dropdown-item:hover {
            background: rgba(255, 215, 0, 0.1);
        }
        
        .task-dropdown-item:last-child {
            border-bottom: none;
        }

        /* Task search input */
        .task-search {
            position: relative;
            min-width: 200px;
        }
        
        .task-search input {
            width: 100%;
            padding: 10px 30px 10px 14px;
            border: 1px solid rgba(255, 215, 0, 0.25);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.25);
            color: #FFD700;
            font-size: 13px;
        }
        
        .task-search input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        .task-search input:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.15);
        }
        
        .task-search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 215, 0, 0.7);
            font-size: 14px;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            transition: all 0.2s ease;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .task-search-clear:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #FFD700;
        }
        
        /* Cookie Banner Styles */
        .cookie-banner {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(40, 40, 40, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5), 
                        0 0 15px rgba(255, 215, 0, 0.2);
            max-width: 500px;
            width: 90%;
            animation: slideInUp 0.5s ease-out;
        }
        
        .cookie-content {
            padding: 20px;
            text-align: center;
        }
        
        .cookie-content h3 {
            color: #FFD700;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.5rem;
            text-shadow: 0 1px 3px rgba(0,0,0,0.6);
        }
        
        .cookie-content p {
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 20px;
            font-size: 15px;
            line-height: 1.5;
        }
        
        .cookie-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .cookie-buttons button {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        
        .cookie-buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .cookie-buttons .btn-success {
            background: #FFD700;
            color: #333;
        }
        
        .cookie-buttons .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(5px);
        }
        
        @keyframes slideInUp {
            from {
                transform: translate(-50%, 100px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }
        
        .container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .glass-card {
            background: rgba(255, 215, 0, 0.05); /* Subtle gold tint */
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 215, 0, 0.15); /* Subtle gold border */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            padding: 40px;
            width: 100%;
            max-width: 1200px;
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .login-card {
            max-width: 400px;
            text-align: center;
        }
        
        .title {
            color: #FFD700; /* Kirmes gold */
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            color: rgba(255, 215, 0, 0.8); /* Gold tint */
            font-size: 1.1rem;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        
        .form-label {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            margin-bottom: 8px;
            display: block;
        }
        
        .form-input {
            width: 100%;
            padding: 15px 20px;
            border: 1px solid rgba(255, 215, 0, 0.3); /* Gold border */
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3); /* Dark background */
            color: #FFD700; /* Gold text */
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .form-input::placeholder {
            color: rgba(255, 215, 0, 0.6); /* Gold placeholder */
        }
        
        .form-input:focus {
            outline: none;
            border-color: #FFD700; /* Gold focus border */
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
        }
        
        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #FFD700, #FFA500); /* Kirmes gold gradient */
            color: #000; /* Black text on gold */
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.3);
            background: linear-gradient(135deg, #FFA500, #FFD700);
        }
        
        .error-message {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }
        
        .search-input {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #FFD700;
            font-size: 18px;
            margin: 0 auto 30px auto;
            display: block;
        }
        
        .search-input::placeholder {
            color: rgba(255, 215, 0, 0.6);
        }
        
        .search-input:focus {
            outline: none;
            border-color: #FFD700;
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.2);
        }
        
        .nav-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .nav-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 215, 0, 0.2); /* Gold tint */
            color: #FFD700; /* Gold text */
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .nav-btn:hover, .nav-btn.active {
            background: rgba(255, 215, 0, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
        }
        
        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .status-success {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.4);
            color: #28a745;
        }
        
        .status-info {
            background: rgba(23, 162, 184, 0.2);
            border: 1px solid rgba(23, 162, 184, 0.4);
            color: #17a2b8;
        }
        
        /* Clickable person tags styling */
        .person-tag {
            cursor: pointer;
            position: relative;
            transition: all 0.25s ease;
            touch-action: manipulation; /* Improve touch behavior */
            -webkit-tap-highlight-color: transparent; /* Remove default mobile tap highlight */
        }
        
        .person-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            background: rgba(255, 215, 0, 0.25) !important;
            border-color: rgba(255, 215, 0, 0.5) !important;
        }
        
        .person-tag:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: all 0.1s ease;
        }
        
        /* Badge for selected tags */
        .person-tag.selected::after {
            content: "✓";
            position: absolute;
            top: -8px;
            right: -8px;
            background: #FFD700;
            color: #000;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 0, 0, 0.1);
            animation: fadeIn 0.3s ease;
        }
    </style>
    <!-- Smart header styles -->
    <!-- Removed external smart-header.css - all styles now inline in React component -->
</head>
<body>
    <!-- Modern clean background -->
    
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Cookie and Local Storage utilities
        const StorageKeys = {
            TASKS: 'kirmes_tasks_data',
            LOGIN_STATUS: 'kirmes_login_status',
            ADMIN_STATUS: 'kirmes_admin_status',
            LOGIN_COOKIE: 'kirmes_login_cookie',
            COOKIE_CONSENT: 'kirmes_cookie_consent'
        };
        
        // Cookie utilities
        const setCookie = (name, value, daysToExpire = 30) => {
            const date = new Date();
            date.setTime(date.getTime() + (daysToExpire * 24 * 60 * 60 * 1000));
            const expires = "expires=" + date.toUTCString();
            document.cookie = name + "=" + value + ";" + expires + ";path=/";
            console.log(`🍪 Cookie set: ${name}`);
        };
        
        const getCookie = (name) => {
            const cookieName = name + "=";
            const cookies = document.cookie.split(';');
            for(let i = 0; i < cookies.length; i++) {
                let cookie = cookies[i].trim();
                if (cookie.indexOf(cookieName) === 0) {
                    return cookie.substring(cookieName.length, cookie.length);
                }
            }
            return "";
        };
        
        const deleteCookie = (name) => {
            document.cookie = name + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            console.log(`🍪 Cookie deleted: ${name}`);
        };
        
        const loadFromStorage = (key, defaultValue = null) => {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : defaultValue;
            } catch (error) {
                console.error('Error loading from storage:', error);
                return defaultValue;
            }
        };
        
        // CSV Processing
        const processCSV = (csvText) => {
            return new Promise((resolve, reject) => {
                Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    delimiter: ';', // German CSV uses semicolon
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.error('CSV parsing errors:', results.errors);
                        }
                        
                        // Transform CSV data to our format - MAINTAIN ORDER
                        const tasks = [];
                        
                        results.data.forEach((row, index) => {
                            // Parse assigned persons (separated by semicolon in quotes)
                            const assignedPersons = row.Zugewiesene_Personen || '';
                            const persons = assignedPersons.split(';').map(p => p.trim().replace(/"/g, '')).filter(p => p);
                            
                            // If there are no assigned persons, create a single task entry without persons
                            if (persons.length === 0) {
                                tasks.push({
                                    id: `${index}-empty`,
                                    originalOrder: index, // Keep original CSV order
                                    name: '', // Empty name for unassigned tasks
                                    task: row.Aufgabe || '',
                                    date: row.Tag || '',
                                    time: row.Zeit || '',
                                    location: row.Standort || '',
                                    taskId: row.Task_ID || '',
                                    status: row.Status || ''
                                });
                            } else {
                                // Create individual tasks for each person, but keep them grouped
                                persons.forEach((person, personIndex) => {
                                    tasks.push({
                                        id: `${index}-${personIndex}`,
                                        originalOrder: index, // Keep original CSV order
                                        name: person,
                                        task: row.Aufgabe || '',
                                        date: row.Tag || '',
                                        time: row.Zeit || '',
                                        location: row.Standort || '',
                                        taskId: row.Task_ID || '',
                                        status: row.Status || ''
                                    });
                                });
                            }
                        });
                        
                        // Sort by original order to maintain chronological sequence - include ALL tasks
                        const validTasks = tasks
                            .filter(task => task.task && task.task.length > 0) // Only filter out tasks without task names
                            .sort((a, b) => a.originalOrder - b.originalOrder);
                        
                        // Debug stats for task count
                        const tasksByDay = {};
                        validTasks.forEach(task => {
                            if (!tasksByDay[task.date]) tasksByDay[task.date] = 0;
                            tasksByDay[task.date]++;
                        });
                        
                        const emptyTasks = validTasks.filter(task => !task.name || task.name.length === 0);
                        
                        resolve(validTasks);
                    },
                    error: function(error) {
                        reject(error);
                    }
                });
            });
        };
        
        // Login Component - Password Only
        const LoginPage = ({ onLogin, onWrongPassword, error }) => {
            const [password, setPassword] = useState('');
            
            const handleLogin = (e) => {
                e.preventDefault();
                if (password === 'kirmes2025') {  // Main login password
                    // Check if cookies are allowed and pass that information
                    const cookieConsent = getCookie(StorageKeys.COOKIE_CONSENT) === "true";
                    onLogin(password, cookieConsent);
                } else {
                    onWrongPassword();
                    setPassword(''); // Clear password field
                }
            };
            
            return (
                <div className="container">
                    <div className="glass-card login-card">
                        <h1 className="title">Kirmes in Kettig</h1>
                        <p className="subtitle">Dienstplan 2025</p>
                        
                        {error && (
                            <div className="error-message">{error}</div>
                        )}
                        
                        <form onSubmit={handleLogin}>
                            <div className="form-group">
                                <label className="form-label">Passwort eingeben</label>
                                <input
                                    type="password"
                                    className="form-input"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    placeholder="Passwort für Dienstplan..."
                                    required
                                />
                            </div>
                            <button type="submit" className="btn">
                                Dienstplan anzeigen
                            </button>
                        </form>
                        
                        <div style={{ marginTop: '20px', fontSize: '14px', color: 'rgba(255, 255, 255, 0.7)' }}>
                            <p>Das Passwort findest du in der Kirmes WhatsApp Gruppe</p>
                        </div>
                    </div>
                </div>
            );
        };
        
        // Task Viewer Component - Modern Layout with Filters
        const TaskViewer = React.memo(({ tasks, onLogout }) => {
            // Add debug log to track when component actually re-renders vs re-mounts
            console.log("TaskViewer RENDER (not re-mount) - tasks count:", tasks.length);
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedDay, setSelectedDay] = useState('');
            const [selectedTask, setSelectedTask] = useState('');
            const [taskSearchTerm, setTaskSearchTerm] = useState('');
            const [showTaskDropdown, setShowTaskDropdown] = useState(false);
            
            // Get unique days and tasks for filters
            const uniqueDays = [...new Set(tasks.map(task => task.date))].filter(Boolean);
            const uniqueTasks = [...new Set(tasks.map(task => task.task))].filter(Boolean).sort();
            
            // Sort days in Kirmes order: Freitag, Samstag, Sonntag, Montag, Dienstag, Mittwoch
            const dayOrder = ['Freitag', 'Samstag', 'Sonntag', 'Montag', 'Dienstag', 'Mittwoch'];
            const sortedDays = uniqueDays.sort((a, b) => {
                const indexA = dayOrder.indexOf(a);
                const indexB = dayOrder.indexOf(b);
                // If day not found in order, put it at the end
                if (indexA === -1) return 1;
                if (indexB === -1) return -1;
                return indexA - indexB;
            });
            
            // Filter tasks for dropdown based on search term
            const filteredDropdownTasks = uniqueTasks.filter(task => 
                task.toLowerCase().includes(taskSearchTerm.toLowerCase())
            );
            
            // Handle task input changes
            const handleTaskInputChange = (e) => {
                const value = e.target.value;
                setTaskSearchTerm(value);
                setSelectedTask(''); // Clear selection when typing
                setShowTaskDropdown(value.length > 0); // Show dropdown when typing
            };
            
            // Helper function to force recalculate content padding
            // Helper function that redirects to our unified content padding handler
            // This is kept for backward compatibility - all calls go to handleContentPaddingUpdate
            const forceUpdateContentPadding = (withDebug = false) => {
                // Delegate to our primary unified handler with appropriate reason
                handleContentPaddingUpdate(withDebug ? "force update with debug" : "force update");
                
                // If we're forcing with debug, log extra information about current state
                if (withDebug) {
                    const header = document.querySelector('.header-section');
                    const content = document.querySelector('.content-section');
                    const exportMenu = document.querySelector('.export-menu');
                    
                    if (header && content) {
                        console.log('🔍 Force update debug info:', {
                            headerHeight: header.offsetHeight,
                            contentPadding: window.getComputedStyle(content).paddingTop,
                            manuallyHidden: manuallyHidden,
                            isInitialLoad: document.body.classList.contains('initial-load'),
                            hasSearchTerm: !!searchTerm,
                            exportMenuPosition: exportMenu ? exportMenu.style.top : 'N/A'
                        });
                    }
                }
            };
            
            const handleTaskSelect = (task) => {
                setTaskSearchTerm(task);
                setSelectedTask(task);
                setShowTaskDropdown(false);
                // Force update padding after selection changes with debug info
                setTimeout(() => forceUpdateContentPadding(true), 100);
                // Second check with a longer delay
                setTimeout(() => forceUpdateContentPadding(false), 500);
            };
            
            const clearTaskSearch = () => {
                setTaskSearchTerm('');
                setSelectedTask('');
                setShowTaskDropdown(false);
                // Force update padding after clearing with debug info
                setTimeout(() => forceUpdateContentPadding(true), 100);
                // Second check with a longer delay
                setTimeout(() => forceUpdateContentPadding(false), 500);
            };
            
            // Group tasks by their original order (chronological)
            const groupTasksByOriginal = (tasks) => {
                const taskGroups = {};
                tasks.forEach(task => {
                    const key = `${task.date}-${task.time}-${task.location}-${task.task}`;
                    if (!taskGroups[key]) {
                        taskGroups[key] = {
                            date: task.date,
                            time: task.time,
                            location: task.location,
                            task: task.task,
                            taskId: task.taskId,
                            persons: []
                        };
                    }
                    // Only add person if they exist (not empty for unassigned tasks)
                    if (task.name && task.name.length > 0) {
                        taskGroups[key].persons.push(task.name);
                    }
                });
                return Object.values(taskGroups);
            };
            
            const groupedTasks = groupTasksByOriginal(tasks);
            
            // Function to update export menu position based on header state - simplified for consistency
            const updateExportMenuPosition = () => {
                const exportMenu = document.querySelector('.export-menu');
                if (!exportMenu) return;
                
                const header = document.querySelector('.header-section');
                if (!header) return;
                
                // Get standard buffer from CSS variables - single source of truth
                const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                
                // Clear any existing transition styles for consistency
                exportMenu.style.transition = 'none';
                
                if (manuallyHidden) {
                    // Manually hidden header - fixed position for export menu
                    exportMenu.style.top = '30px';
                    exportMenu.style.position = 'sticky';
                    exportMenu.style.marginTop = '0px';
                    console.log('📋 Export menu positioned for manually hidden header: 30px');
                } else {
                    // Standard positioning for all non-hidden states (initial load, post-initial, and normal)
                    const headerHeight = header.offsetHeight || 200; // Fallback
                    const top = headerHeight + standardBuffer;
                    
                    // Always use sticky positioning for consistency - same behavior in all states
                    exportMenu.style.top = `${top}px`;
                    exportMenu.style.position = 'sticky';
                    exportMenu.style.marginTop = '0px';
                    
                    console.log('📋 Export menu positioned consistently:', {
                        headerHeight: headerHeight,
                        exportMenuTop: top
                    });
                }
            };
            
            // Filter tasks based on all criteria
            const filteredTasks = groupedTasks.filter(task => {
                // For name search: if no search term, show all tasks
                // If search term exists, show only tasks with matching persons
                const matchesName = searchTerm.trim() === '' || 
                    task.persons.some(person => 
                        person.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                
                const matchesDay = selectedDay === '' || task.date === selectedDay;
                
                // Task filter: check both dropdown selection and search term
                const matchesTask = (selectedTask === '' || task.task === selectedTask) &&
                    (taskSearchTerm.trim() === '' || task.task.toLowerCase().includes(taskSearchTerm.toLowerCase()));
                
                return matchesName && matchesDay && matchesTask;
            });
            
            // Smart header that hides on scroll down, shows on scroll up
            const [headerVisible, setHeaderVisible] = useState(true);
            const [lastScrollY, setLastScrollY] = useState(0);
            // Start with collapsed instructions by default
            const [isExpanded, setIsExpanded] = useState(false);
            // User can manually toggle header visibility
            const [manuallyHidden, setManuallyHidden] = useState(false);
            // Flag to track initial load completion
            const [initialLoadComplete, setInitialLoadComplete] = useState(false);
            
            // Handle scroll events for smart header
            useEffect(() => {
                console.log("Setting up scroll handlers - React version");
                
                // Check for presence of required elements and log results
                const headerElement = document.querySelector('.header-section');
                const contentElement = document.querySelector('.content-section');
                console.log("Elements check:", { 
                    header: headerElement ? "Found" : "Missing",
                    content: contentElement ? "Found" : "Missing"
                });
                
                // Variable to track touch direction for mobile
                // Enhanced scroll detection system for container-based scrolling
                let lastScrollPosition = 0;
                let scrollDirection = 'none';
                let scrollTimer = null;
                let isScrolling = false;
                let currentVisibleTaskIndex = 0;
                let totalTasks = filteredTasks.length;
                let isInitialMount = true; // Flag to prevent auto-hide during initial mount
                
                // Minimum scroll distance to trigger header hide/show
                const SCROLL_THRESHOLD = 100;
                const SCROLL_TOP_THRESHOLD = 50;
                
                // Get the actual scroll container (content-section)
                const getScrollContainer = () => {
                    return document.querySelector('.content-section');
                };
                
                // Calculate which task is currently visible at the top of the viewport
                const calculateVisibleTaskIndex = (scrollContainer) => {
                    if (!scrollContainer) return 0;
                    
                    const taskCards = scrollContainer.querySelectorAll('.task-card');
                    const containerRect = scrollContainer.getBoundingClientRect();
                    const scrollTop = scrollContainer.scrollTop;
                    
                    // Find the first task that's visible in the viewport
                    for (let i = 0; i < taskCards.length; i++) {
                        const taskRect = taskCards[i].getBoundingClientRect();
                        const relativeTop = taskRect.top - containerRect.top + scrollTop;
                        
                        if (relativeTop >= scrollTop - 50) { // 50px buffer
                            return i;
                        }
                    }
                    
                    return Math.max(0, taskCards.length - 1); // Default to last task if at bottom
                };
                
                // Enhanced scroll handler that works with the content container
                const handleScroll = (event) => {
                    const scrollContainer = event?.target || getScrollContainer();
                    if (!scrollContainer || scrollContainer.className !== 'content-section') {
                        return; // Only handle scroll events from the content section
                    }
                    
                    if (scrollTimer) {
                        clearTimeout(scrollTimer);
                    }
                    
                    isScrolling = true;
                    
                    scrollTimer = setTimeout(() => {
                        const currentScrollY = scrollContainer.scrollTop;
                        const scrollDelta = currentScrollY - lastScrollPosition;
                        
                        // Determine scroll direction with threshold to avoid micro-movements
                        if (Math.abs(scrollDelta) > 5) {
                            if (scrollDelta > 0) {
                                scrollDirection = 'down';
                            } else {
                                scrollDirection = 'up';
                            }
                        }
                        
                        // Calculate current visible task
                        const newVisibleTaskIndex = calculateVisibleTaskIndex(scrollContainer);
                        const taskIndexChanged = newVisibleTaskIndex !== currentVisibleTaskIndex;
                        currentVisibleTaskIndex = newVisibleTaskIndex;
                        
                        // Calculate scroll percentage
                        const maxScroll = scrollContainer.scrollHeight - scrollContainer.clientHeight;
                        const scrollPercentage = maxScroll > 0 ? (currentScrollY / maxScroll) * 100 : 0;
                        
                        // Enhanced debug logging with task information
                        console.log('📊 Enhanced Scroll Event:', {
                            position: Math.round(currentScrollY),
                            delta: Math.round(scrollDelta),
                            direction: scrollDirection,
                            headerState: manuallyHidden ? 'HIDDEN' : 'VISIBLE',
                            visibleTaskIndex: currentVisibleTaskIndex + 1, // Show 1-based index
                            totalTasks: totalTasks,
                            scrollPercentage: Math.round(scrollPercentage),
                            willTrigger: shouldTriggerHeaderChange(currentScrollY, scrollDirection),
                            taskChanged: taskIndexChanged
                        });
                        
                        // Apply header logic based on scroll position and direction
                        handleHeaderVisibility(currentScrollY, scrollDirection);
                        
                        lastScrollPosition = currentScrollY;
                        isScrolling = false;
                    }, 50); // 50ms debounce - prevents too frequent updates
                };
                
                // Determine if header state should change
                const shouldTriggerHeaderChange = (scrollY, direction) => {
                    // Always show at top
                    if (scrollY <= SCROLL_TOP_THRESHOLD) return true;
                    
                    // Hide when scrolling down past threshold
                    if (direction === 'down' && scrollY > SCROLL_THRESHOLD && !manuallyHidden) return true;
                    
                    // Don't auto-show when scrolling up (user must use button)
                    return false;
                };
                
                // Handle header visibility changes
                const handleHeaderVisibility = (scrollY, direction) => {
                    // Don't trigger auto-hide during initial mount to prevent conflicts with manual toggles
                    if (isInitialMount) {
                        console.log('🚫 Skipping auto-hide during initial mount, scrollY:', scrollY, 'direction:', direction);
                        return;
                    }
                    
                    // Case 1: At the very top - always show header
                    if (scrollY <= SCROLL_TOP_THRESHOLD) {
                        if (manuallyHidden) {
                            console.log('🔝 At top - showing header (scrollY:', scrollY, ')');
                            toggleHeaderManually();
                        }
                        return;
                    }
                    
                    // Case 2: Auto-hide when scrolling down past task 1 (reduced from task 2)
                    if (direction === 'down' && currentVisibleTaskIndex >= 1 && !manuallyHidden && scrollY > 11) {
                        console.log('⬇️ Auto-hiding header - past task 1, scrollY:', scrollY, 'current task index:', currentVisibleTaskIndex + 1);
                        
                        // Also collapse instructions if they're expanded
                        if (isExpanded) {
                            console.log('📝 Auto-collapsing instructions');
                            setIsExpanded(false);
                        }
                        
                        // Hide the header
                        toggleHeaderManually();
                        return;
                    }
                    
                    // Case 3: Already hidden and scrolling further down - do nothing
                    if (direction === 'down' && manuallyHidden) {
                        console.log('⬇️ Scrolling down with header already hidden - no action needed, task index:', currentVisibleTaskIndex + 1);
                        return;
                    }
                    
                    // Case 4: Scrolling up - header stays hidden (user must manually show header)
                    if (direction === 'up' && manuallyHidden) {
                        console.log('⬆️ Scrolling up - header stays hidden (manual toggle required), task index:', currentVisibleTaskIndex + 1);
                        return;
                    }
                };
                
                // Touch handling for mobile devices (simplified)
                let touchStartY = 0;
                let touchMoveTimer = null;
                
                const handleTouchStart = (e) => {
                    touchStartY = e.touches[0].clientY;
                };
                
                const handleTouchMove = (e) => {
                    // Only handle touch moves when not already scrolling via scroll events
                    if (isScrolling) return;
                    
                    if (touchMoveTimer) clearTimeout(touchMoveTimer);
                    
                    const touchY = e.touches[0].clientY;
                    const touchDelta = touchStartY - touchY;
                    
                    // Debounce touch moves
                    touchMoveTimer = setTimeout(() => {
                        // Only trigger on significant touch movement
                        if (Math.abs(touchDelta) > 20) {
                            const touchDirection = touchDelta > 0 ? 'down' : 'up';
                            
                            // Get current scroll position from the content container
                            const scrollContainer = getScrollContainer();
                            const currentScrollY = scrollContainer ? scrollContainer.scrollTop : 0;
                            
                            console.log('👆 Touch movement:', {
                                delta: Math.round(touchDelta),
                                direction: touchDirection,
                                scrollY: Math.round(currentScrollY),
                                taskIndex: currentVisibleTaskIndex
                            });
                            
                            // Apply same logic as scroll
                            handleHeaderVisibility(currentScrollY, touchDirection);
                        }
                        
                        touchStartY = touchY;
                    }, 100); // Longer debounce for touch
                };
                
                // Add event listeners to the correct scroll container
                const scrollContainer = getScrollContainer();
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', handleScroll, { passive: true });
                    console.log('📦 Attached scroll listener to content-section container');
                } else {
                    console.warn('⚠️ Content section not found, falling back to window scroll');
                    window.addEventListener('scroll', handleScroll, { passive: true });
                }
                
                // Touch events still go on window since they're global gestures
                window.addEventListener('touchstart', handleTouchStart, { passive: true });
                window.addEventListener('touchmove', handleTouchMove, { passive: true });
                
                // Update total tasks when filtered tasks change
                totalTasks = filteredTasks.length;
                
                // Set initial mount flag to false after a short delay to allow manual toggles to work
                const initialMountTimer = setTimeout(() => {
                    isInitialMount = false;
                    console.log('✅ Initial mount period ended - auto-hide logic now active');
                }, 1000); // 1 second delay to prevent conflicts with manual button presses
                
                // Also handle scroll button visibility separately from header visibility
                const updateScrollButtonVisibility = () => {
                    const scrollButton = document.getElementById('scrollTopButton');
                    const scrollContainer = getScrollContainer();
                    const currentScroll = scrollContainer ? scrollContainer.scrollTop : window.scrollY;
                    
                    if (scrollButton) {
                        // Always show the scroll button (except on login screen)
                        scrollButton.style.opacity = '1';
                        scrollButton.style.pointerEvents = 'auto';
                        scrollButton.style.transform = 'scale(1)';
                    }
                    
                    // Update the header toggle button appearance and text
                    const toggleBtn = document.getElementById('header-toggle-button');
                    if (toggleBtn) {
                        toggleBtn.style.opacity = currentScroll > 10 ? '0.9' : '0.6';
                        
                        // Update button text based on header state
                        // Check both React state and DOM state for consistent behavior
                        const isActuallyHidden = manuallyHidden || document.body.classList.contains('manually-hidden-header');
                        
                        if (isActuallyHidden) {
                            toggleBtn.textContent = '▲ Suche anzeigen';
                        } else {
                            toggleBtn.textContent = '▼ Suche ausblenden';
                        }
                    }
                };
                
                // Attach scroll button update to the correct container
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', updateScrollButtonVisibility, { passive: true });
                } else {
                    window.addEventListener('scroll', updateScrollButtonVisibility, { passive: true });
                }
                // Call immediately to set initial state
                setTimeout(updateScrollButtonVisibility, 100);
                
                // Use the global resize handler for consistency
                if (window.globalResizeHandler) {
                    window.addEventListener('resize', window.globalResizeHandler);
                    // Call once on mount to apply styles
                    window.globalResizeHandler();
                    
                    // Check header height after a short delay to ensure all content is rendered
                    setTimeout(window.globalResizeHandler, 500);
                } else {
                    console.warn('⚠️ Global resize handler not available yet');
                    
                    // Temporary fallback handler if global handler isn't ready
                    const tempHandleResize = () => {
                        // Set smaller initial search bar padding on mobile
                        if (window.innerWidth < 480) {
                            const searchInput = document.querySelector('.primary-search input');
                            if (searchInput) {
                                searchInput.style.padding = '12px 30px 12px 12px';
                                searchInput.style.fontSize = '16px';
                            }
                        }
                        
                        handleContentPaddingUpdate("window resize in scroll handler");
                    };
                    
                    window.addEventListener('resize', tempHandleResize);
                    tempHandleResize();
                    setTimeout(tempHandleResize, 500);
                }
                
                return () => {
                    // Clean up all event listeners
                    const scrollContainer = getScrollContainer();
                    if (scrollContainer) {
                        scrollContainer.removeEventListener('scroll', handleScroll);
                        scrollContainer.removeEventListener('scroll', updateScrollButtonVisibility);
                    } else {
                        window.removeEventListener('scroll', handleScroll);
                        window.removeEventListener('scroll', updateScrollButtonVisibility);
                    }
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchmove', handleTouchMove);
                    
                    // Remove global resize handler if available
                    if (window.globalResizeHandler) {
                        window.removeEventListener('resize', window.globalResizeHandler);
                    } else {
                        // Fallback to remove temporary handler
                        window.removeEventListener('resize', tempHandleResize);
                    }
                    
                    // Clear any pending timers
                    if (touchMoveTimer) clearTimeout(touchMoveTimer);
                    if (scrollTimer) clearTimeout(scrollTimer);
                    if (initialMountTimer) clearTimeout(initialMountTimer);
                };
            }, [lastScrollY, isExpanded]); // Removed manuallyHidden to prevent scroll system restart
            
            // Calculate header height for proper content padding
            useEffect(() => {
                // Legacy updateContentPadding function - delegates all calls to handleContentPaddingUpdate
                // This is maintained for backward compatibility with existing code
                const updateContentPadding = (forceUpdate = false) => {
                    console.log('👉 Legacy updateContentPadding called - delegating to unified handler');
                    
                    // Simply call our unified handler with appropriate reason
                    handleContentPaddingUpdate(forceUpdate ? "legacy force update" : "legacy update");
                    
                    // For backward compatibility - return true to indicate success
                    return true;
                };
                
                // Run immediately on mount for faster initial positioning - using unified handler
                handleContentPaddingUpdate("initial mount"); // Force update on mount
                
                // Reduced timer setup to prevent spam - only essential checks - using unified handler
                const immediateTimer = setTimeout(() => handleContentPaddingUpdate("delayed initial"), 100);
                const finalTimer = setTimeout(() => handleContentPaddingUpdate("final initial"), 800);
                
                // Create a global resize handler that all resize events can use
                window.globalResizeHandler = () => {
                    // Single source of truth for resize handling
                    handleContentPaddingUpdate("global window resize");
                    
                    // Handle mobile-specific adjustments
                    if (window.innerWidth < 480) {
                        const searchInput = document.querySelector('.primary-search input');
                        if (searchInput) {
                            searchInput.style.paddingLeft = '30px';
                        }
                    }
                    
                    // Update export menu position
                    updateExportMenuPosition();
                };
                
                // Register our main resize handler
                window.addEventListener('resize', window.globalResizeHandler);
                
                // Special handler for the expand/collapse of instructions
                let mutationTimer = null;
                const headerObserver = new MutationObserver((mutations) => {
                    // Only trigger on meaningful changes that affect height
                    const significantChange = mutations.some(mutation => {
                        // Check for class changes that affect visibility/state
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            return true;
                        }
                        // Check for structural changes (adding/removing elements)
                        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                            return true;
                        }
                        // Ignore style changes and minor mutations
                        return false;
                    });
                    
                    if (significantChange) {
                        // Debounce mutations to prevent spam
                        if (mutationTimer) clearTimeout(mutationTimer);
                        mutationTimer = setTimeout(() => handleContentPaddingUpdate("DOM mutation"), 300);
                    }
                });
                
                // Observe changes to the header to catch any dynamic height changes
                if (document.querySelector('.header-section')) {
                    headerObserver.observe(document.querySelector('.header-section'), {
                        attributes: true,
                        attributeFilter: ['class', 'style'], // Only watch class and style changes
                        childList: true, // Watch for adding/removing elements
                        subtree: false, // Don't watch deep children
                        characterData: false // Don't watch text changes
                    });
                }
                
                return () => {
                    clearTimeout(immediateTimer);
                    clearTimeout(finalTimer);
                    if (mutationTimer) clearTimeout(mutationTimer);
                    if (window.globalResizeHandler) {
                        window.removeEventListener('resize', window.globalResizeHandler);
                    }
                    headerObserver.disconnect();
                };
            }, [headerVisible, isExpanded]); // Removed manuallyHidden to prevent constant re-calculation
            
            // Separate effect for manual header visibility changes (prevents full system restart)
            useEffect(() => {
                // Only handle padding adjustments for manual visibility changes
                const header = document.querySelector('.header-section');
                const content = document.querySelector('.content-section');
                const exportMenu = document.querySelector('.export-menu');
                
                // Update body class to track manually hidden state
                if (manuallyHidden) {
                    document.body.classList.add('manually-hidden-header');
                } else {
                    document.body.classList.remove('manually-hidden-header');
                }
                
                // Check if we're in initial load phase
                const isInitialLoad = document.body.classList.contains('initial-load');
                const isPostInitial = document.body.classList.contains('post-initial-transition');
                
                if (header && content) {
                    if (manuallyHidden) {
                        // Fixed padding when header is manually hidden - use CSS variable for value
                        const manualHiddenPadding = getComputedStyle(document.documentElement).getPropertyValue('--manual-hidden-padding') || '20px';
                        content.style.setProperty('padding-top', manualHiddenPadding, 'important');
                        
                        // Update export menu position through the dedicated function for consistency
                        updateExportMenuPosition();
                        
                        console.log('🔒 Manual hide - padding locked to ' + manualHiddenPadding);
                        
                        // Hide the header visually for additional confirmation
                        header.style.display = 'none';
                        
                        // STOP other padding monitors when manually hidden
                        if (window.paddingMonitor) {
                            clearInterval(window.paddingMonitor);
                            window.paddingMonitor = null;
                        }
                    } else if (!isInitialLoad && !isPostInitial) {
                        // Show the header visually
                        header.style.display = '';
                        // Only recalculate if we're not in initial load or post-initial transition phase
                        // Use our unified handler instead of direct calculation
                        handleContentPaddingUpdate("manual show");
                        
                        // Update export menu position through the dedicated function
                        updateExportMenuPosition();
                        
                        console.log('🔓 Manual show - padding restored via unified handler');
                    } else {
                        console.log('⚠️ Skipping manual show during special phase:', 
                            isInitialLoad ? 'initial-load' : 'post-initial-transition');
                    }
                }
            }, [manuallyHidden]); // Only manuallyHidden dependency
            
            // Add initial-load class to body on component mount and remove after initialization
            useEffect(() => {
                // Add the initial-load class to prevent overlap during loading
                document.body.classList.add('initial-load');
                
                // Set proper initial padding immediately
                const content = document.querySelector('.content-section');
                const header = document.querySelector('.header-section');
                if (content && header) {
                    // Use our unified handler for consistent padding calculation
                    
                    // Force header to be visible for measurement
                    const originalDisplay = header.style.display;
                    const originalVisibility = header.style.visibility;
                    
                    header.style.display = 'block';
                    header.style.visibility = 'visible';
                    
                    // Force reflow for accurate measurement
                    void header.offsetHeight;
                    
                    // Get accurate height
                    const headerHeight = header.offsetHeight || 200; // Fallback height
                    
                    // Use the same standard buffer as normal operation for consistency
                    // Get buffer from CSS variable
                    const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                    const safeInitialPadding = Math.ceil(headerHeight + standardBuffer); // Round up to avoid fractional pixels
                    
                    // Store globally so our unified handler can use it
                    window.initialLoadPadding = safeInitialPadding;
                    
                    // Use our unified handler for initial padding
                    handleContentPaddingUpdate("initial setup");
                    
                    console.log('🚀 Initial padding setup via unified handler:', safeInitialPadding + 'px');
                    
                    // Restore original properties
                    header.style.display = originalDisplay;
                    header.style.visibility = originalVisibility;
                    
                    // Add a monitoring system to detect if padding gets reset
                    // Store the monitor reference globally so we can clear old ones
                    if (window.paddingMonitor) {
                        clearInterval(window.paddingMonitor);
                    }
                    
                    // Store this value globally so other padding systems can respect it during initial load
                    window.initialLoadPadding = safeInitialPadding;
                    
                    window.paddingMonitor = setInterval(() => {
                        // More aggressive padding monitoring during initial load phase
                        if (document.body.classList.contains('initial-load')) {
                            // Calculate standard padding - same calculation as normal operation
                            const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                            const headerHeight = header.offsetHeight || 200;
                            const standardPadding = Math.ceil(headerHeight + standardBuffer);
                            
                            const currentPadding = window.getComputedStyle(content).paddingTop;
                            const expectedPadding = `${standardPadding}px`;
                            
                            // Always enforce padding during initial load, even if it looks right
                            // This prevents momentary flashes of incorrect padding
                            content.style.setProperty('padding-top', expectedPadding, 'important');
                            
                            // Log only if it was incorrect
                            if (currentPadding !== expectedPadding) {
                                console.warn('🚨 Padding was reset during initial load!', {
                                    expected: expectedPadding,
                                    current: currentPadding,
                                    restoring: true
                                });
                            }
                            
                            // Also update other elements that might be affected
                            // Always retrieve the export menu fresh from the DOM, don't rely on closure
                            const exportMenuElement = document.querySelector('.export-menu');
                            if (exportMenuElement) {
                                exportMenuElement.style.top = '280px'; // Keep consistent with our other settings
                                exportMenuElement.style.position = 'relative';
                                exportMenuElement.style.marginTop = '5px';
                            }
                        }
                    }, 50); // Check very frequently (50ms) to catch any resets
                    
                    // Clear monitor after 5 seconds or when initial-load class is removed
                    setTimeout(() => {
                        if (window.paddingMonitor) {
                            clearInterval(window.paddingMonitor);
                            window.paddingMonitor = null;
                            console.log('⏱️ Padding monitor cleared after timeout');
                        }
                    }, 5000);
                }
                
                // Remove the initial-load class after all rendering is stable
                // Extended to 1000ms to ensure more complete stability
                const removeInitialLoadClass = setTimeout(() => {
                    if (!content) return; // Safety check
                    
                    // Calculate padding using the standard buffer we use everywhere else
                    const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                    const headerHeight = header.offsetHeight || 200;
                    const standardPadding = headerHeight + standardBuffer;
                    
                    // Use our consistent padding value for the transition
                    content.style.setProperty('padding-top', `${standardPadding}px`, 'important');
                    
                    // Store the value before transition for verification
                    const beforeTransitionPadding = window.getComputedStyle(content).paddingTop;
                    console.log('🔍 Pre-transition padding check:', beforeTransitionPadding);
                    
                    // Begin transition process with stages
                    setTimeout(() => {
                        // 1. Apply post-initial class to prevent transition
                        document.body.classList.add('post-initial-transition');
                        
                        // 2. Remove initial-load class
                        document.body.classList.remove('initial-load');
                        console.log('🎬 Initial load class removed - transition phase started');
                        
                        // 3. Force a padding update with special transition handler
                        handleContentPaddingUpdate("post-initial transition");
                        
                        // 4. After a delay, complete the transition to normal operation
                        setTimeout(() => {
                            document.body.classList.remove('post-initial-transition');
                            
                            // 5. Final padding update for normal operation
                            handleContentPaddingUpdate("normal operation");
                            console.log('✅ Transition complete - normal operation active');
                        }, 100);
                    }, 50);
                }, 1000); // Extended to 1000ms to ensure all content is stable
                
                return () => {
                    clearTimeout(removeInitialLoadClass);
                    document.body.classList.remove('initial-load'); // Clean up
                };
            }, []);
            
            // Special effect to handle search term changes and update content padding
            useEffect(() => {
                console.log('🔍 Search term changed, recalculating layout:', searchTerm);
                
                // Skip padding updates during initial load or when manually hidden
                const isInitialLoad = document.body.classList.contains('initial-load');
                const isActuallyHidden = manuallyHidden || document.body.classList.contains('manually-hidden-header');
                
                if (isInitialLoad || isActuallyHidden) {
                    console.log('🔍 Search term changed but skipping padding update due to:', 
                        isInitialLoad ? 'initial load phase' : 'manually hidden header');
                    return;
                }
                
                // Use our specialized handler with proper debouncing
                let timers = [];
                
                // Initial quick update for fast feedback
                timers.push(setTimeout(() => {
                    handleContentPaddingUpdate("search term initial");
                    updateExportMenuPosition();
                }, 10));
                
                // Main update with sufficient delay for DOM changes
                timers.push(setTimeout(() => {
                    handleContentPaddingUpdate("search term main");
                }, 250));
                
                // Final verification with longer delay
                timers.push(setTimeout(() => {
                    // Verify padding is sufficient using our constants for consistency
                    const content = document.querySelector('.content-section');
                    const header = document.querySelector('.header-section');
                    
                    if (content && header) {
                        const headerHeight = header.offsetHeight;
                        const currentPadding = parseInt(window.getComputedStyle(content).paddingTop);
                        // Use our standard buffer from CSS variables for consistency
                        const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                        const minRequiredPadding = headerHeight + standardBuffer;
                        
                        console.log('🔍 Final search term padding verification:', {
                            term: searchTerm,
                            headerHeight,
                            currentPadding,
                            minRequiredPadding,
                            isCorrect: currentPadding >= minRequiredPadding
                        });
                        
                        // Force correct padding if it's too small
                        if (currentPadding < minRequiredPadding) {
                            console.log('⚠️ FINAL CORRECTION - using unified handler');
                            handleContentPaddingUpdate("final search correction");
                        }
                    }
                }, 500));
                
                // Return cleanup function to clear timers on component unmount or search term change
                return () => {
                    timers.forEach(timer => clearTimeout(timer));
                };
            }, [searchTerm, manuallyHidden]);
            
            // Effect to update export menu position whenever header state changes
            useEffect(() => {
                const timer = setTimeout(updateExportMenuPosition, 100);
                return () => clearTimeout(timer);
            }, [manuallyHidden, headerVisible]);
            
            // Effect to synchronize button text with header state on mount and state changes
            useEffect(() => {
                // This ensures the button text always matches the actual state
                const syncButtonText = () => {
                    const toggleBtn = document.getElementById('header-toggle-button');
                    if (toggleBtn) {
                        const isActuallyHidden = manuallyHidden || document.body.classList.contains('manually-hidden-header');
                        toggleBtn.textContent = isActuallyHidden ? '▲ Suche anzeigen' : '▼ Suche ausblenden';
                        console.log('🔄 Synchronized button text with header state:', isActuallyHidden ? 'hidden' : 'visible');
                    }
                };
                
                // Run immediately
                syncButtonText();
                
                // And also after a short delay to ensure DOM is updated
                const timer = setTimeout(syncButtonText, 200);
                
                return () => clearTimeout(timer);
            }, [manuallyHidden]);
            
            // Effect to highlight the instructions button when scrolled down and instructions are hidden
            useEffect(() => {
                // If we've scrolled down and instructions are closed, highlight the button
                const shouldHighlightButton = lastScrollY > 100 && !isExpanded && !manuallyHidden;
                
                // Find the instructions button
                const instructionsButton = document.querySelector('.instructions-toggle-button');
                if (instructionsButton) {
                    if (shouldHighlightButton) {
                        // Add a subtle pulse animation to draw attention, but only briefly
                        // so it doesn't become annoying to the user
                        instructionsButton.style.animation = 'pulseHighlight 2s ease-in-out';
                        instructionsButton.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                        
                        // Remove the animation after a few pulses
                        setTimeout(() => {
                            if (instructionsButton) {
                                instructionsButton.style.animation = '';
                                // Keep a subtle glow
                                instructionsButton.style.boxShadow = '0 0 5px rgba(255, 215, 0, 0.3)';
                            }
                        }, 4000);
                    } else {
                        // Remove animation when not needed
                        instructionsButton.style.animation = '';
                        instructionsButton.style.boxShadow = isExpanded ? 
                            '0 0 8px rgba(255, 215, 0, 0.5)' : 
                            'none';
                    }
                }
            }, [lastScrollY, isExpanded, manuallyHidden]);
            
            // Function to update CSS variables for consistent padding values
            const updateCSSVariables = (variables) => {
                Object.entries(variables).forEach(([name, value]) => {
                    document.documentElement.style.setProperty(name, value);
                });
            };
            
            // Create style element to add CSS rules that block other padding attempts
            const ensureCriticalStyles = () => {
                // Check if our style is already added
                if (document.getElementById('critical-padding-styles')) return;
                
                // Set initial CSS variables with consistent values
                const header = document.querySelector('.smart-header');
                const headerHeight = header ? header.offsetHeight : 200;
                
                updateCSSVariables({
                    '--manual-hidden-padding': '20px',
                    '--standard-buffer': '15px',
                    '--search-buffer': '15px', // Make search buffer same as standard
                    '--header-height': `${headerHeight}px` // Add header height variable
                });
                
                // Create a style element for our critical rules
                const style = document.createElement('style');
                style.id = 'critical-padding-styles';
                style.innerHTML = `
                    /* Critical padding rules to prevent unwanted transitions */
                    .initial-load .content-section {
                        transition: none !important; /* Prevent transitions during initial load */
                        /* We'll use dynamic calculation instead of a CSS variable */
                    }
                    
                    /* Manually hidden header state */
                    .manually-hidden-header .content-section {
                        padding-top: var(--manual-hidden-padding, 20px) !important;
                        transition: padding-top 0.2s ease-out !important;
                    }
                    
                    /* Normal state - controlled by our unified handler */
                    .content-section {
                        /* Use transition only after initial load completed */
                        transition: padding-top 0.2s ease-out !important;
                    }
                    
                    /* Special transition state */
                    .post-initial-transition .content-section {
                        transition: none !important;
                    }
                `;
                document.head.appendChild(style);
                console.log('🛡️ Added enhanced critical padding protection styles');
            };
            
            // Ensure our critical styles are added
            ensureCriticalStyles();
            
            // PRIMARY HANDLER: Universal unified content padding function
            // This is the single source of truth for all padding calculations
            const handleContentPaddingUpdate = (reason = "general") => {
                console.log(`📏 Updating content padding (reason: ${reason})`);
                
                const header = document.querySelector('.header-section');
                const content = document.querySelector('.content-section');
                const exportMenu = document.querySelector('.export-menu');
                
                if (!header || !content) {
                    console.warn('⚠️ Cannot update padding - header or content element not found');
                    return;
                }
                
                // Update CSS variable for header height
                const currentHeaderHeight = header.offsetHeight;
                document.documentElement.style.setProperty('--header-height', `${currentHeaderHeight}px`);
                
                // Check if we're in initial load phase
                const isInitialLoad = document.body.classList.contains('initial-load');
                
                // CASE 1: Handle manually hidden header state
                // Check both the React state AND the DOM class for more reliable detection
                const isActuallyHidden = manuallyHidden || document.body.classList.contains('manually-hidden-header');
                
                if (isActuallyHidden) {
                    // Use CSS variable for consistent value
                    const manualHiddenPadding = getComputedStyle(document.documentElement).getPropertyValue('--manual-hidden-padding') || '20px';
                    content.style.setProperty('padding-top', manualHiddenPadding, 'important');
                    
                    // Update export menu position if available
                    if (exportMenu) {
                        // Use the same value for consistency
                        exportMenu.style.top = '30px';
                        exportMenu.style.position = 'sticky';
                        exportMenu.style.marginTop = '0px';
                    }
                    
                    console.log('🔒 Padding locked to ' + manualHiddenPadding + ' (header manually hidden)');
                    return;
                }
                
                // CASE 2: Handle initial load phase
                if (isInitialLoad) {
                    // Calculate standard padding the same way we do for normal operation
                    const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                    const headerHeight = header.offsetHeight || 200;
                    const standardPadding = Math.ceil(headerHeight + standardBuffer);
                    
                    // Use standard padding during load phase for consistency
                    content.style.setProperty('padding-top', `${standardPadding}px`, 'important');
                    
                    // Position export menu appropriately during initial load
                    if (exportMenu) {
                        // Position exactly the same as normal operation
                        exportMenu.style.top = `${headerHeight + standardBuffer}px`;
                        exportMenu.style.position = 'sticky';
                        exportMenu.style.marginTop = '0px';
                    }
                    
                    console.log('🚀 Using standard padding for initial load:', standardPadding + 'px');
                    return;
                }
                
                // SPECIAL CASE: Handle transition from initial to normal (post-initial)
                // This prevents jumps when switching from initial-load to normal operation
                if (reason === "post-initial transition") {
                    // Apply a special class for this transitional state
                    document.body.classList.add('post-initial-transition');
                    
                    // Calculate standard padding just like in normal operation
                    const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                    const headerHeight = header.offsetHeight || 200;
                    const standardPadding = headerHeight + standardBuffer;
                    
                    content.style.setProperty('padding-top', `${standardPadding}px`, 'important');
                    
                    console.log('🔄 Smooth transition using standard padding:', standardPadding + 'px');
                    
                    // Remove the transitional class after the transition completes
                    setTimeout(() => {
                        document.body.classList.remove('post-initial-transition');
                        handleContentPaddingUpdate("post-transition cleanup");
                    }, 100);
                    
                    return;
                }
                
                // CASE 3: Normal operation - calculate dynamic padding
                
                // Force visibility for accurate measurement if needed
                const headerIsHidden = window.getComputedStyle(header).display === 'none' || 
                                       window.getComputedStyle(header).visibility === 'hidden';
                
                let originalDisplay, originalVisibility;
                if (headerIsHidden) {
                    // Store original properties
                    originalDisplay = header.style.display;
                    originalVisibility = header.style.visibility;
                    
                    // Temporarily make visible for measurement
                    header.style.display = 'block';
                    header.style.visibility = 'visible';
                    
                    // Force reflow for accurate measurement
                    void header.offsetHeight;
                }
                
                // Measure header height
                const headerHeight = header.offsetHeight || 200; // Fallback if measurement fails
                
                // CONSTANTS FOR CONSISTENT PADDING
                // Define standard buffer sizes to maintain consistency across all calculations
                const STANDARD_BUFFER = 15; // Standard buffer for all cases
                const SEARCH_BUFFER = 20;   // Buffer when search term is active
                
                // Calculate base padding with consistent buffer
                const buffer = (reason.includes('search') || searchTerm) ? SEARCH_BUFFER : STANDARD_BUFFER;
                let totalPadding = headerHeight + buffer;
                
                // Account for export menu if it should be visible
                if (exportMenu && searchTerm) {
                    // Force visibility for measurement if needed
                    const menuIsHidden = window.getComputedStyle(exportMenu).display === 'none';
                    const originalMenuDisplay = exportMenu.style.display;
                    
                    if (menuIsHidden) {
                        exportMenu.style.display = 'block';
                        void exportMenu.offsetHeight; // Force reflow
                    }
                    
                    const exportMenuHeight = exportMenu.offsetHeight || 80;
                    const exportMenuMargin = 20; // Allow for margin
                    totalPadding += exportMenuMargin; // Add margin, not entire height since it's positioned separately
                    
                    // Update export menu position
                    const standardBuffer = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--standard-buffer') || '15');
                    exportMenu.style.top = `${headerHeight + standardBuffer}px`;
                    exportMenu.style.position = 'sticky';
                    
                    // Restore original display if changed
                    if (menuIsHidden) {
                        exportMenu.style.display = originalMenuDisplay;
                    }
                    
                    console.log('📦 Export menu positioned at:', `${headerHeight + standardBuffer}px`);
                }
                
                // If we temporarily made header visible, restore original properties
                if (headerIsHidden && originalDisplay !== undefined) {
                    header.style.display = originalDisplay;
                    header.style.visibility = originalVisibility;
                }
                
                // Apply the padding with high specificity
                content.style.setProperty('padding-top', `${totalPadding}px`, 'important');
                
                console.log('� Padding updated:', {
                    reason: reason,
                    headerHeight: headerHeight,
                    totalPadding: totalPadding,
                    hasSearchTerm: !!searchTerm,
                    isManuallyHidden: isActuallyHidden, // Use the accurate state from above
                    domClassHasHidden: document.body.classList.contains('manually-hidden-header'),
                    reactStateHidden: manuallyHidden,
                    isInitialLoad: isInitialLoad
                });
            };
            
            // Function to toggle header visibility manually - simplified to prevent React re-mounting
            
            // Function to toggle header visibility manually - uses unified padding handler
            const toggleHeaderManually = () => {
                console.log("Toggle header button clicked!");
                
                const newHiddenState = !manuallyHidden;
                
                // Apply changes to the body class immediately for faster visual feedback
                if (newHiddenState) {
                    document.body.classList.add('manually-hidden-header');
                    
                    // Apply direct padding for immediate visual feedback when hiding
                    const content = document.querySelector('.content-section');
                    if (content) {
                        const manualHiddenPadding = getComputedStyle(document.documentElement).getPropertyValue('--manual-hidden-padding') || '20px';
                        content.style.setProperty('padding-top', manualHiddenPadding, 'important');
                    }
                    
                    // Immediately update the toggle button text when hiding
                    const toggleBtn = document.getElementById('header-toggle-button');
                    if (toggleBtn) {
                        toggleBtn.textContent = '▲ Suche anzeigen';
                    }
                    
                    // Hide the header visually right away
                    const header = document.querySelector('.header-section');
                    if (header) {
                        header.style.display = 'none';
                    }
                } else {
                    document.body.classList.remove('manually-hidden-header');
                    
                    // Immediately update the toggle button text when showing
                    const toggleBtn = document.getElementById('header-toggle-button');
                    if (toggleBtn) {
                        toggleBtn.textContent = '▼ Suche ausblenden';
                    }
                    
                    // Show the header visually right away
                    const header = document.querySelector('.header-section');
                    if (header) {
                        header.style.display = '';
                    }
                }
                
                // Update React state
                setManuallyHidden(newHiddenState);
                
                // Skip the unified handler call which is causing inconsistency
                // The useEffect for manuallyHidden will handle the padding properly
                
                console.log(`🔄 Header ${newHiddenState ? 'hiding' : 'showing'} - direct DOM update applied`);
            };
            
            return (
                <div className="main-layout">
                    {/* Toggle button for header visibility - always visible at top of content */}
                    <button 
                        id="header-toggle-button"
                        className="header-toggle-btn"
                        onClick={() => {
                            console.log("Button clicked directly");
                            toggleHeaderManually();
                        }}
                        onDoubleClick={() => {
                            // Force toggle via double-click - simplified
                            console.log("FORCE TOGGLE via double-click");
                            setManuallyHidden(!manuallyHidden);
                        }}
                        style={{
                            position: 'fixed',
                            top: manuallyHidden ? '5px' : '0',
                            left: '50%',
                            transform: 'translateX(-50%)',
                            background: manuallyHidden 
                                ? 'rgba(255, 215, 0, 0.4)' 
                                : 'rgba(255, 215, 0, 0.2)',
                            border: '1px solid rgba(255, 215, 0, 0.6)',
                            borderRadius: manuallyHidden ? '20px' : '0 0 20px 20px',
                            padding: '8px 16px', // Larger for better visibility
                            fontSize: '13px', // Slightly larger
                            fontWeight: '600',
                            color: '#FFD700',
                            cursor: 'pointer',
                            zIndex: 2001, // Higher than header (2000)
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            boxShadow: '0 2px 6px rgba(0, 0, 0, 0.4)',
                            transition: 'all 0.3s ease',
                            width: 'auto',
                            minWidth: '120px',
                            textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)',
                        }}
                    >
                        {manuallyHidden ? '▲ Suche anzeigen' : '▼ Suche ausblenden'}
                    </button>
                    
                    {/* Smart Header with Filters - Hides on scroll down, Shows on scroll up */}
                    <div 
                        id="react-header-section"
                        className={`header-section ${headerVisible && !manuallyHidden ? 'sticky-visible' : 'header-hidden'}`} 
                        style={{
                            transform: (headerVisible && !manuallyHidden) ? 'translateY(0)' : 'translateY(-100%)',
                            opacity: (headerVisible && !manuallyHidden) ? 1 : 0,
                            pointerEvents: (headerVisible && !manuallyHidden) ? 'auto' : 'none',
                            transition: 'transform 0.3s ease-out, opacity 0.3s ease-out',
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            width: '100%',
                            zIndex: 2000,
                            // Don't use display:none as it causes layout shifts
                            // and prevents smooth animations
                        }}>
                        <div className="filter-container">
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
                                <h1 style={{ color: '#FFD700', margin: 0, fontSize: '2rem' }}>
                                    Dienstplan 2025
                                </h1>
                                
                                {/* Toggle Button for Instructions */}
                                <button 
                                    className="instructions-toggle-button"
                                    onClick={() => setIsExpanded(!isExpanded)}
                                    style={{
                                        background: isExpanded ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 215, 0, 0.2)',
                                        border: '1px solid rgba(255, 215, 0, 0.5)',
                                        borderRadius: '24px',
                                        padding: '8px 15px',
                                        display: 'flex',
                                        justifyContent: 'center',
                                        alignItems: 'center',
                                        cursor: 'pointer',
                                        transition: 'all 0.2s ease',
                                        color: isExpanded ? '#000' : '#FFD700',
                                        fontWeight: isExpanded ? 'bold' : 'normal',
                                        fontSize: '14px',
                                        marginLeft: '15px',
                                        boxShadow: isExpanded ? '0 0 8px rgba(255, 215, 0, 0.5)' : 'none'
                                    }}
                                    title={isExpanded ? "Anleitung ausblenden" : "Anleitung einblenden"}
                                >
                                    {isExpanded ? '✕ Anleitung' : 'ℹ️ Anleitung'}
                                </button>
                            </div>
                            
                            {/* Collapsible Instructions Box - only shown when button is clicked */}
                            {isExpanded && (
                                <div style={{ 
                                    background: 'rgba(33, 33, 33, 0.9)',
                                    border: '1px solid rgba(255, 215, 0, 0.3)',
                                    borderRadius: '12px',
                                    padding: '15px 20px',
                                    marginBottom: '15px',
                                    fontSize: '14px',
                                    color: '#fff',
                                    animation: 'fadeIn 0.4s ease',
                                    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
                                    maxHeight: '500px',
                                    overflow: 'hidden',
                                    transition: 'all 0.4s ease'
                                }}>
                                    <p style={{ margin: '0 0 5px 0', textAlign: 'center', fontWeight: 'bold' }}>
                                        🔍 So funktioniert die Suche:
                                    </p>
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Gib deinen Namen ein ODER klicke auf deinen Namen in einer Aufgabe, um alle deine Aufgaben zu sehen
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Tag oder Aufgabe filtern über die Dropdown-Menüs
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Klicke erneut auf deinen Namen, um den Filter aufzuheben
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            Ergebnisse per WhatsApp an dich selbst oder andere senden
                                        </p>
                                        <p style={{ margin: '0', display: 'flex', alignItems: 'center' }}>
                                            <span style={{ 
                                                color: '#FFD700', 
                                                fontSize: '18px', 
                                                marginRight: '8px', 
                                                display: 'inline-block',
                                                lineHeight: '14px',
                                                width: '14px',
                                                height: '14px',
                                                borderRadius: '50%',
                                                background: 'rgba(255, 215, 0, 0.2)', 
                                                textAlign: 'center' 
                                            }}>•</span>
                                            PDF erstellen oder Aufgaben ausdrucken
                                        </p>
                                    </div>
                                </div>
                            )}
                            
                            {/* Primary Name Search */}
                            <div className="primary-search">
                                <input
                                    type="text"
                                    value={searchTerm}
                                    onChange={(e) => {
                                        const newValue = e.target.value;
                                        setSearchTerm(newValue);
                                        
                                        // Use our specialized handler for immediate feedback
                                        setTimeout(() => {
                                            if (!manuallyHidden) {
                                                // If adding a search term (showing export menu)
                                                if (newValue && !searchTerm) {
                                                    console.log('🔍 Search started - ensuring proper padding');
                                                    handleContentPaddingUpdate("search term");
                                                }
                                                // If clearing a search term (hiding export menu)
                                                else if (!newValue && searchTerm) {
                                                    console.log('🔍 Search cleared - ensuring proper padding');
                                                    handleContentPaddingUpdate("search term");
                                                }
                                            }
                                        }, 50);
                                    }}
                                    placeholder="Nach Namen suchen..."
                                />
                                {/* Clear search button */}
                                {searchTerm && (
                                    <button
                                        className="search-clear-btn"
                                        onClick={() => setSearchTerm('')}
                                        title="Suche löschen"
                                    >
                                        ✕
                                    </button>
                                )}
                            </div>
                            
                            {/* Secondary Filters */}
                            <div className="secondary-filters">
                                {/* Day Filter */}
                                <select 
                                    className="filter-select"
                                    value={selectedDay}
                                    onChange={(e) => setSelectedDay(e.target.value)}
                                >
                                    <option value="">Alle Tage</option>
                                    {sortedDays.map(day => (
                                        <option key={day} value={day}>
                                            {day === 'Freitag' ? 'Freitag, 22. August' : 
                                             day === 'Samstag' ? 'Samstag, 23. August' :
                                             day === 'Sonntag' ? 'Sonntag, 24. August' :
                                             day === 'Montag' ? 'Montag, 25. August' :
                                             day === 'Dienstag' ? 'Dienstag, 26. August' :
                                             day === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                             day}
                                        </option>
                                    ))}
                                </select>
                                
                                {/* Task Search Combo */}
                                <div className="task-search-combo">
                                    <input
                                        type="text"
                                        value={taskSearchTerm}
                                        onChange={handleTaskInputChange}
                                        onFocus={() => setShowTaskDropdown(taskSearchTerm.length > 0)}
                                        onBlur={() => setTimeout(() => setShowTaskDropdown(false), 200)} // Delay to allow click
                                        placeholder="Aufgabe suchen..."
                                    />
                                    
                                    {/* Dropdown arrow */}
                                    <button
                                        className="task-dropdown-btn"
                                        onClick={() => setShowTaskDropdown(!showTaskDropdown)}
                                        title="Aufgaben anzeigen"
                                    >
                                        ▼
                                    </button>
                                    
                                    {/* Clear button */}
                                    {taskSearchTerm && (
                                        <button
                                            className="task-search-clear"
                                            onClick={clearTaskSearch}
                                            title="Suche löschen"
                                        >
                                            ✕
                                        </button>
                                    )}
                                    
                                    {/* Dropdown list */}
                                    {showTaskDropdown && (
                                        <div className="task-dropdown">
                                            {filteredDropdownTasks.length > 0 ? (
                                                filteredDropdownTasks.map((task, index) => (
                                                    <div
                                                        key={index}
                                                        className="task-dropdown-item"
                                                        onClick={() => handleTaskSelect(task)}
                                                    >
                                                        {task}
                                                    </div>
                                                ))
                                            ) : (
                                                <div className="task-dropdown-item" style={{ color: 'rgba(255, 215, 0, 0.6)', cursor: 'default' }}>
                                                    Keine passenden Aufgaben gefunden
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                                
                                {/* Clear Filters - Always visible for consistent positioning */}
                                <button 
                                    className="nav-btn"
                                    onClick={() => {
                                        setSearchTerm('');
                                        setSelectedDay('');
                                        setSelectedTask('');
                                        clearTaskSearch();
                                    }}
                                    style={{ 
                                        padding: '8px 16px', 
                                        fontSize: '12px',
                                        opacity: (searchTerm || selectedDay || selectedTask || taskSearchTerm) ? 1 : 0.5
                                    }}
                                    disabled={!(searchTerm || selectedDay || selectedTask || taskSearchTerm)}
                                >
                                    {searchTerm ? '👥 Alle anzeigen' : '🔄 Reset'}
                                </button>
                            </div>
                        </div>
                        
                        {/* Results Info - Only show when searching for a person */}
                        {searchTerm && (
                            <div className="export-menu" style={{ 
                                maxWidth: '1200px', 
                                margin: '15px auto 0 auto',
                                padding: '10px 15px',
                                background: 'rgba(40, 167, 69, 0.2)',
                                border: '1px solid rgba(40, 167, 69, 0.4)',
                                borderRadius: '8px',
                                color: '#28a745',
                                textAlign: 'center',
                                fontSize: '14px',
                                zIndex: 1500, /* High enough to appear above content but below header */
                                position: 'relative'
                            }}>
                                <div className="export-buttons" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', flexWrap: 'wrap', gap: '10px' }}>
                                    <span>{filteredTasks.length} Aufgaben gefunden {searchTerm && `für "${searchTerm}"`}</span>
                                    
                                    {/* WhatsApp sharing button */}
                                    <button 
                                        className="nav-btn"
                                        onClick={() => {
                                            // Format tasks as text
                                            const tasksText = filteredTasks
                                                .map(t => `📍 ${t.task}:\n${t.date}, ${t.time}`)
                                                .join('\n\n');
                                            const whatsappText = `Kirmes Aufgaben für ${searchTerm}:\n\n${tasksText}`;
                                            
                                            // Show an info message before opening WhatsApp
                                            alert("Tipp: Du kannst die Nachricht an dich selbst oder an andere Personen senden.\n\nWähle einfach einen Kontakt aus oder nutze die 'An mich selbst senden' Funktion in WhatsApp.");
                                            
                                            // Open WhatsApp with pre-filled message
                                            window.open(`https://wa.me/?text=${encodeURIComponent(whatsappText)}`);
                                        }}
                                        style={{ 
                                            padding: '4px 12px', 
                                            fontSize: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px'
                                        }}
                                        title="An WhatsApp senden - Du kannst die Nachricht auch an dich selbst senden"
                                    >
                                        <span style={{fontSize: '16px'}}>📱</span> Per WhatsApp teilen
                                    </button>
                                    
                                    {/* PDF Export button */}
                                    <button 
                                        className="nav-btn"
                                        onClick={() => {
                                            // Create a temporary div for PDF generation
                                            const pdfContent = document.createElement('div');
                                            pdfContent.innerHTML = `
                                                <div style="font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto;">
                                                    <h1 style="text-align: center; color: #FFD700; margin-bottom: 10px;">Kirmes in Kettig - Dienstplan 2025</h1>
                                                    <h2 style="text-align: center; margin-bottom: 30px;">Aufgaben für ${searchTerm}</h2>
                                                    ${filteredTasks.map((task, idx) => `
                                                        <div style="margin-bottom: 25px; padding: 15px; border: 1px solid #ccc; border-radius: 10px; page-break-inside: avoid;">
                                                            <h3 style="margin-top: 0; color: #FFD700;">📍 ${task.task}</h3>
                                                            <p><strong>📅 Datum:</strong> ${
                                                                task.date === 'Freitag' ? 'Freitag, 22. August' : 
                                                                task.date === 'Samstag' ? 'Samstag, 23. August' :
                                                                task.date === 'Sonntag' ? 'Sonntag, 24. August' :
                                                                task.date === 'Montag' ? 'Montag, 25. August' :
                                                                task.date === 'Dienstag' ? 'Dienstag, 26. August' :
                                                                task.date === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                                                task.date
                                                            }</p>
                                                            <p><strong>🕐 Uhrzeit:</strong> ${task.time}</p>
                                                            <p><strong>👥 Zugewiesene Personen:</strong></p>
                                                            <ul style="padding-left: 20px;">
                                                                ${task.persons.map(person => `
                                                                    <li style="${person.toLowerCase().includes(searchTerm.toLowerCase()) ? 'font-weight: bold;' : ''}">${person} ${person.toLowerCase().includes(searchTerm.toLowerCase()) ? '←' : ''}</li>
                                                                `).join('')}
                                                            </ul>
                                                        </div>
                                                    `).join('')}
                                                    <div style="text-align: center; margin-top: 30px; font-size: 12px; color: #888;">
                                                        Generiert am ${new Date().toLocaleDateString('de-DE')} für ${searchTerm}
                                                    </div>
                                                </div>
                                            `;
                                            
                                            // Generate PDF with proper configuration
                                            const opt = {
                                                margin:       [10, 10],
                                                filename:     `Kirmes_Dienstplan_${searchTerm.replace(/\s+/g, '_')}.pdf`,
                                                image:        { type: 'jpeg', quality: 0.98 },
                                                html2canvas:  { scale: 2, useCORS: true },
                                                jsPDF:        { unit: 'mm', format: 'a4', orientation: 'portrait' }
                                            };
                                            
                                            html2pdf().set(opt).from(pdfContent).save();
                                        }}
                                        style={{ 
                                            padding: '4px 12px', 
                                            fontSize: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px'
                                        }}
                                        title="Als PDF speichern"
                                    >
                                        <span style={{fontSize: '16px'}}>📄</span> Als PDF speichern
                                    </button>
                                    
                                    {/* Print button */}
                                    <button 
                                        className="nav-btn"
                                        onClick={() => {
                                            // Use a simple print approach that modifies the page and restores it
                                            // Get current date for footer
                                            const currentDate = new Date().toLocaleDateString('de-DE');
                                            
                                            // Store original styles to restore later
                                            const contentDiv = document.querySelector('.content-section > div');
                                            const taskCards = document.querySelectorAll('.task-card');
                                            const originalStyles = {
                                                contentMargin: contentDiv?.style.margin,
                                                taskCardMargin: Array.from(taskCards).map(card => card.style.marginBottom)
                                            };
                                            
                                            // Create a custom print container
                                            const printContent = document.createElement('div');
                                            printContent.id = "print-content";
                                            printContent.style.position = "fixed";
                                            printContent.style.top = "0";
                                            printContent.style.left = "0";
                                            printContent.style.width = "100%";
                                            printContent.style.background = "white";
                                            printContent.style.zIndex = "9999";
                                            printContent.style.padding = "0";
                                            printContent.style.margin = "0";
                                            printContent.style.fontFamily = "Arial, sans-serif";
                                            
                                            // Generate HTML for printing
                                            printContent.innerHTML = `
                                                <div style="font-family: Arial, sans-serif; padding: 15px; margin: 0 auto;">
                                                    <div style="text-align: center; margin: 0 0 5px 0; padding: 0;">
                                                        <div style="font-size: 16pt; font-weight: bold; margin: 0; padding: 0;">
                                                            Kirmes in Kettig - Dienstplan 2025
                                                        </div>
                                                        <div style="font-size: 14pt; font-weight: bold; margin: 5px 0; padding: 0 0 2px 0; border-bottom: 1px dotted #ccc;">
                                                            ${searchTerm ? `Aufgaben für ${searchTerm}` : `Alle Aufgaben (${filteredTasks.length})`}
                                                        </div>
                                                    </div>
                                                    
                                                    <div style="margin-top: 10px;">
                                                    ${filteredTasks.map((task, idx) => `
                                                        <div style="margin-bottom: 8px; padding: 8px; border: 1px solid #ccc; border-radius: 5px; page-break-inside: avoid;">
                                                            <div style="display: flex; justify-content: space-between; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 5px;">
                                                                <div style="flex: 1;">
                                                                    <div style="font-weight: bold; font-size: 12pt; margin: 0; color: black;">
                                                                        📍 ${task.task}
                                                                    </div>
                                                                </div>
                                                                <div style="text-align: right;">
                                                                    <div style="font-weight: bold; font-size: 10pt; color: black;">
                                                                        📅 ${task.date === 'Freitag' ? 'Freitag, 22. August' : 
                                                                             task.date === 'Samstag' ? 'Samstag, 23. August' :
                                                                             task.date === 'Sonntag' ? 'Sonntag, 24. August' :
                                                                             task.date === 'Montag' ? 'Montag, 25. August' :
                                                                             task.date === 'Dienstag' ? 'Dienstag, 26. August' :
                                                                             task.date === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                                                             task.date}
                                                                    </div>
                                                                    <div style="font-size: 10pt; color: black;">
                                                                        🕐 ${task.time}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div>
                                                                <div style="font-size: 10pt; margin-bottom: 5px; font-weight: bold; color: black;">
                                                                    👥 Zugewiesene Personen (${task.persons.length}):
                                                                </div>
                                                                <div style="display: flex; flex-wrap: wrap; gap: 5px;">
                                                                    ${task.persons.map(person => `
                                                                        <span style="
                                                                            display: inline-block;
                                                                            padding: 2px 6px;
                                                                            margin: 0;
                                                                            border-radius: 3px;
                                                                            font-size: 9pt;
                                                                            ${person.toLowerCase().includes(searchTerm.toLowerCase()) ? 
                                                                                'background-color: #ffeb99; font-weight: bold;' : 
                                                                                'background-color: #f5f5f5;'
                                                                            }
                                                                            color: black;
                                                                        ">
                                                                            ${person} ${person.toLowerCase().includes(searchTerm.toLowerCase()) ? '←' : ''}
                                                                        </span>
                                                                    `).join('')}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    `).join('')}
                                                    </div>
                                                    
                                                    <div style="text-align: center; margin-top: 15px; font-size: 10pt; color: #666; font-style: italic;">
                                                        ${searchTerm ? 
                                                            `Vielen Dank für deine Unterstützung bei der Kirmes in Kettig 2025, ${searchTerm}!` : 
                                                            `Alle Aufgaben für die Kirmes in Kettig 2025`
                                                        }
                                                        <br/>
                                                        <span style="font-size: 8pt; margin-top: 5px; display: block;">
                                                            Ausgedruckt am ${currentDate}
                                                        </span>
                                                    </div>
                                                </div>
                                            `;
                                            
                                            // Add the print container to the body
                                            document.body.appendChild(printContent);
                                            
                                            // Create print-specific style to hide everything else
                                            const printStyle = document.createElement('style');
                                            printStyle.id = 'print-style';
                                            printStyle.innerHTML = `
                                                @media print {
                                                    body * {
                                                        visibility: hidden;
                                                    }
                                                    #print-content, #print-content * {
                                                        visibility: visible;
                                                    }
                                                    #print-content {
                                                        position: absolute;
                                                        left: 0;
                                                        top: 0;
                                                        width: 100%;
                                                        padding-top: 0 !important;
                                                        margin-top: 0 !important;
                                                    }
                                                    @page {
                                                        margin: 0.5cm;
                                                        size: A4 portrait;
                                                    }
                                                    html, body {
                                                        height: auto !important;
                                                        margin: 0 !important;
                                                        padding: 0 !important;
                                                    }
                                                }
                                            `;
                                            document.head.appendChild(printStyle);
                                            
                                            // Trigger print after a short delay to ensure the content is rendered
                                            setTimeout(() => {
                                                window.print();
                                                
                                                // Clean up after printing
                                                setTimeout(() => {
                                                    // Remove the temporary elements
                                                    document.body.removeChild(printContent);
                                                    document.head.removeChild(printStyle);
                                                    
                                                    // Restore original styles if needed
                                                    if (contentDiv && originalStyles.contentMargin) {
                                                        contentDiv.style.margin = originalStyles.contentMargin;
                                                    }
                                                    taskCards.forEach((card, index) => {
                                                        if (originalStyles.taskCardMargin[index]) {
                                                            card.style.marginBottom = originalStyles.taskCardMargin[index];
                                                        }
                                                    });
                                                }, 500);
                                            }, 200);
                                        }}
                                        style={{ 
                                            padding: '4px 12px', 
                                            fontSize: '12px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '5px'
                                        }}
                                        title="Aufgaben drucken"
                                    >
                                        <span style={{fontSize: '16px'}}>🖨️</span> Drucken
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Scrollable Content */}
                    <div className="content-section">
                        <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                            {filteredTasks.map((task, index) => (
                                <div key={index} className="task-card" style={{
                                    background: 'rgba(255, 255, 255, 0.08)',
                                    borderRadius: '12px',
                                    padding: '20px',
                                    marginBottom: '15px',
                                    border: '1px solid rgba(255, 215, 0, 0.15)',
                                    transition: 'all 0.3s ease'
                                }}>
                                    <div style={{
                                        borderBottom: '1px solid rgba(255, 255, 255, 0.1)',
                                        paddingBottom: '10px',
                                        marginBottom: '10px'
                                    }}>
                                        <div className="task-header" style={{
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'flex-start',
                                            gap: '15px',
                                            flexWrap: 'wrap'
                                        }}>
                                            <div style={{ flex: 1 }}>
                                                <h3 className="task-title" style={{ 
                                                    color: '#FFD700', 
                                                    fontSize: '1.3rem', 
                                                    fontWeight: '600',
                                                    margin: '0 0 8px 0'
                                                }}>
                                                    📍 {task.task}
                                                </h3>
                                            </div>
                                            
                                            <div className="task-date-time" style={{
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'flex-end',
                                                gap: '4px',
                                                textAlign: 'right'
                                            }}>
                                                <span style={{
                                                    color: 'rgba(255, 255, 255, 0.9)',
                                                    fontSize: '1rem',
                                                    fontWeight: '600'
                                                }}>
                                                    📅 {task.date === 'Freitag' ? 'Freitag, 22. August' : 
                                                         task.date === 'Samstag' ? 'Samstag, 23. August' :
                                                         task.date === 'Sonntag' ? 'Sonntag, 24. August' :
                                                         task.date === 'Montag' ? 'Montag, 25. August' :
                                                         task.date === 'Dienstag' ? 'Dienstag, 26. August' :
                                                         task.date === 'Mittwoch' ? 'Mittwoch, 27. August' :
                                                         task.date}
                                                </span>
                                                <span style={{
                                                    color: 'rgba(255, 255, 255, 0.8)',
                                                    fontSize: '0.95rem'
                                                }}>
                                                    🕐 {task.time}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <h4 style={{ 
                                            color: 'rgba(255, 255, 255, 0.9)', 
                                            fontSize: '1rem',
                                            marginBottom: '10px',
                                            fontWeight: '500'
                                        }}>
                                            👥 Zugewiesene Personen ({task.persons.length}):
                                        </h4>
                                        <div style={{
                                            display: 'flex',
                                            flexWrap: 'wrap',
                                            gap: '8px'
                                        }}>
                                            {task.persons.length > 0 ? (
                                                task.persons.map((person, personIndex) => (
                                                    <span 
                                                        key={personIndex} 
                                                        className={`person-tag ${searchTerm && person.toLowerCase() === searchTerm.toLowerCase() ? 'selected' : ''}`}
                                                        onClick={(e) => {
                                                            // Add click feedback animation
                                                            const target = e.currentTarget;
                                                            
                                                            // Apply a quick pulse effect
                                                            target.style.transform = 'scale(0.95)';
                                                            setTimeout(() => {
                                                                target.style.transform = 'scale(1.05)';
                                                                setTimeout(() => {
                                                                    target.style.transform = '';
                                                                }, 150);
                                                            }, 150);
                                                            
                                                            // Toggle behavior: if already filtered by this person, clear the filter
                                                            // Otherwise, set this person as the filter
                                                            if (searchTerm && person.toLowerCase() === searchTerm.toLowerCase()) {
                                                                setSearchTerm(''); // Clear the filter
                                                                
                                                                // Visual feedback for clearing filter
                                                                target.animate([
                                                                    { backgroundColor: 'rgba(255, 215, 0, 0.3)', opacity: 1 },
                                                                    { backgroundColor: 'rgba(255, 255, 255, 0.15)', opacity: 0.8 }
                                                                ], { duration: 300, fill: 'forwards' });
                                                                
                                                                // Use unified handler for search term padding
                                                                if (!manuallyHidden) {
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 50);
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 150);
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 300);
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 500);
                                                                }
                                                            } else {
                                                                setSearchTerm(person); // Set the filter
                                                                
                                                                // Visual feedback for setting filter - ripple effect
                                                                const ripple = document.createElement('span');
                                                                ripple.style.position = 'absolute';
                                                                ripple.style.borderRadius = '50%';
                                                                ripple.style.backgroundColor = 'rgba(255, 215, 0, 0.3)';
                                                                ripple.style.transform = 'scale(0)';
                                                                ripple.style.animation = 'ripple 0.6s linear';
                                                                ripple.style.opacity = '1';
                                                                
                                                                // Position the ripple at click point
                                                                const rect = target.getBoundingClientRect();
                                                                ripple.style.width = ripple.style.height = Math.max(rect.width, rect.height) + 'px';
                                                                ripple.style.left = e.clientX - rect.left - (parseInt(ripple.style.width) / 2) + 'px';
                                                                ripple.style.top = e.clientY - rect.top - (parseInt(ripple.style.height) / 2) + 'px';
                                                                
                                                                target.appendChild(ripple);
                                                                
                                                                // Clean up ripple element after animation
                                                                setTimeout(() => {
                                                                    if (ripple && ripple.parentNode === target) {
                                                                        target.removeChild(ripple);
                                                                    }
                                                                }, 600);
                                                                
                                                                // Use unified handler for search term padding
                                                                if (!manuallyHidden) {
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 50);
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 150);
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 300);
                                                                    setTimeout(() => handleContentPaddingUpdate("search term"), 500);
                                                                }
                                                            }
                                                        }}
                                                        style={{
                                                            position: 'relative', // For ripple effect
                                                            overflow: 'hidden', // For ripple effect
                                                            background: searchTerm && person.toLowerCase().includes(searchTerm.toLowerCase())
                                                                ? 'rgba(255, 215, 0, 0.3)' // Highlight searched person
                                                                : 'rgba(255, 255, 255, 0.15)',
                                                            color: searchTerm && person.toLowerCase().includes(searchTerm.toLowerCase())
                                                                ? '#000'
                                                                : '#fff',
                                                            padding: '6px 12px',
                                                            borderRadius: '20px',
                                                            fontSize: '14px',
                                                            fontWeight: '500',
                                                            border: searchTerm && person.toLowerCase().includes(searchTerm.toLowerCase())
                                                                ? '1px solid rgba(255, 215, 0, 0.6)'
                                                                : '1px solid rgba(255, 255, 255, 0.2)',
                                                            cursor: 'pointer',
                                                            transition: 'all 0.2s ease',
                                                            userSelect: 'none', // Prevent text selection when double-clicking
                                                            WebkitTapHighlightColor: 'transparent' // Remove default mobile tap highlight
                                                        }}
                                                        onMouseOver={(e) => {
                                                            // Only apply hover effects if not already selected
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.transform = 'translateY(-2px)';
                                                                e.currentTarget.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 215, 0, 0.2)';
                                                            }
                                                        }}
                                                        onMouseOut={(e) => {
                                                            // Only reset hover effects if not already selected
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.transform = 'translateY(0)';
                                                                e.currentTarget.style.boxShadow = 'none';
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
                                                            }
                                                        }}
                                                        onTouchStart={(e) => {
                                                            // Touch feedback - instantly apply a subtle effect
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 215, 0, 0.15)';
                                                                e.currentTarget.style.transform = 'scale(0.98)';
                                                            }
                                                        }}
                                                        onTouchEnd={(e) => {
                                                            // Reset touch effect unless this is now selected
                                                            if (!(searchTerm && person.toLowerCase() === searchTerm.toLowerCase())) {
                                                                e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
                                                                e.currentTarget.style.transform = '';
                                                            }
                                                        }}
                                                        title={searchTerm && person.toLowerCase() === searchTerm.toLowerCase() 
                                                            ? `Filter für "${person}" aufheben` 
                                                            : `Nach "${person}" filtern`}
                                                    >
                                                        {person}
                                                        {searchTerm && person.toLowerCase() === searchTerm.toLowerCase() && (
                                                            <span style={{ marginLeft: '5px', fontSize: '10px', opacity: 0.7 }}>✕</span>
                                                        )}
                                                    </span>
                                                ))
                                            ) : (
                                                <span style={{
                                                    color: 'rgba(255, 255, 255, 0.5)',
                                                    fontStyle: 'italic',
                                                    fontSize: '14px'
                                                }}>
                                                    Noch keine Personen zugewiesen
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            ))}
                            
                            {/* Show message when no tasks match the filters */}
                            {filteredTasks.length === 0 && (
                                <div style={{
                                    textAlign: 'center',
                                    padding: '30px 20px',
                                    background: 'rgba(0, 0, 0, 0.2)',
                                    borderRadius: '8px',
                                    border: '1px solid rgba(255, 215, 0, 0.2)',
                                }}>
                                    <div style={{ fontSize: '36px', marginBottom: '10px' }}>🔍</div>
                                    <h3 style={{ color: '#FFD700', marginBottom: '10px' }}>Keine passenden Aufgaben gefunden</h3>
                                    <p style={{ color: '#ccc' }}>Bitte versuche es mit anderen Suchkriterien.</p>
                                    <button 
                                        onClick={() => {
                                            setSearchTerm('');
                                            setSelectedDay('');
                                            setSelectedTask('');
                                            setTaskSearchTerm('');
                                        }}
                                        style={{
                                            background: 'rgba(255, 215, 0, 0.2)',
                                            border: '1px solid rgba(255, 215, 0, 0.4)',
                                            borderRadius: '20px',
                                            padding: '8px 15px',
                                            marginTop: '15px',
                                            color: '#FFD700',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        Filter zurücksetzen
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* Scroll to top button - always visible after scrolling a bit */}
                    <button 
                        id="scrollTopButton"
                        onClick={() => {
                            // Get the actual scroll container
                            const scrollContainer = document.querySelector('.content-section');
                            
                            if (scrollContainer) {
                                // Force scroll to top using the container's scroll methods
                                scrollContainer.scrollTo({ top: 0, behavior: 'smooth' });
                                scrollContainer.scrollTop = 0;
                                
                                console.log('📜 Scrolling container to top, container scrollTop:', scrollContainer.scrollTop);
                            } else {
                                // Fallback to window scroll if container not found
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                                document.documentElement.scrollTop = 0;
                                document.body.scrollTop = 0;
                            }
                            
                            // Show the search header when scrolling to top
                            if (manuallyHidden) {
                                toggleHeaderManually();
                            }
                            
                            // Additional force scroll after a small delay
                            setTimeout(() => {
                                if (scrollContainer) {
                                    scrollContainer.scrollTo(0, 0);
                                    scrollContainer.scrollTop = 0;
                                } else {
                                    window.scrollTo(0, 0);
                                    document.documentElement.scrollTop = 0;
                                    document.body.scrollTop = 0;
                                }
                            }, 100);
                        }}
                        style={{
                            position: 'fixed',
                            bottom: '20px',
                            right: '20px',
                            width: '48px',
                            height: '48px',
                            borderRadius: '50%',
                            backgroundColor: 'rgba(255, 215, 0, 0.9)',
                            color: '#000',
                            border: 'none',
                            display: 'flex',
                            opacity: '1', /* Always visible */
                            pointerEvents: 'auto', /* Always interactive */
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '24px',
                            cursor: 'pointer',
                            zIndex: 9999, /* Increased z-index to ensure visibility */
                            boxShadow: '0 4px 15px rgba(0, 0, 0, 0.5)',
                            transition: 'opacity 0.3s ease, transform 0.3s ease',
                            fontWeight: 'bold',
                            transform: 'scale(1)' /* Always full size */
                        }}
                        title="Nach oben"
                    >
                        ↑
                    </button>
                </div>
            );
        }, (prevProps, nextProps) => {
            // Only re-render if tasks array content actually changed
            const tasksChanged = prevProps.tasks.length !== nextProps.tasks.length ||
                                prevProps.tasks !== nextProps.tasks;
            
            if (!tasksChanged) {
                console.log('🚫 React.memo: Preventing re-render - tasks unchanged');
            } else {
                console.log('✅ React.memo: Allowing re-render - tasks changed');
            }
            
            return !tasksChanged; // Return true to PREVENT re-render, false to ALLOW
        });
        
        // Cookie Consent Banner Component
        const CookieBanner = ({ onAccept, onDecline }) => {
            return (
                <div className="cookie-banner">
                    <div className="cookie-content">
                        <h3>Cookies für Login</h3>
                        <p>Diese Website verwendet Cookies, um deine Login-Daten zu speichern.<br />
                        Bei Akzeptieren bleibst du automatisch angemeldet.<br />
                        Bei Ablehnen ist bei jedem Besuch eine erneute Anmeldung erforderlich.</p>
                        <div className="cookie-buttons">
                            <button onClick={onAccept} className="btn btn-success">Akzeptieren</button>
                            <button onClick={onDecline} className="btn btn-secondary">Ablehnen</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        // Main App Component - Simplified
        const App = () => {
            const [isLoggedIn, setIsLoggedIn] = useState(false);
            const [tasks, setTasks] = useState([]);
            const [error, setError] = useState('');
            const [showCookieConsent, setShowCookieConsent] = useState(false);
            const [cookieConsent, setCookieConsent] = useState(false);
            
            // Debug: Log when App component renders
            console.log("🏠 App component rendering - logged in:", isLoggedIn, "tasks count:", tasks.length);
            
            // Check for cookie consent and stored login
            useEffect(() => {
                const consent = getCookie(StorageKeys.COOKIE_CONSENT);
                setCookieConsent(consent === "true");
                
                // If user has consented to cookies, check for stored login
                if (consent === "true") {
                    const storedLogin = getCookie(StorageKeys.LOGIN_COOKIE);
                    if (storedLogin === "kirmes2025") {
                        console.log("🔑 Auto-login from cookie");
                        handleLogin("kirmes2025", true); // Password, cookieAllowed=true
                    }
                } else if (consent === "") {
                    // If no consent decision has been made yet, show the banner
                    setShowCookieConsent(true);
                }
            }, []);
            
            // Handle cookie consent decisions
            const handleCookieAccept = () => {
                setCookieConsent(true);
                setShowCookieConsent(false);
                setCookie(StorageKeys.COOKIE_CONSENT, "true");
            };
            
            const handleCookieDecline = () => {
                setCookieConsent(false);
                setShowCookieConsent(false);
                setCookie(StorageKeys.COOKIE_CONSENT, "false");
                // Remove any existing login cookies
                deleteCookie(StorageKeys.LOGIN_COOKIE);
            };
            
            // Load data from CSV file on component mount
            useEffect(() => {
                // Clear any existing cache first
                if ('caches' in window) {
                    caches.keys().then(function(names) {
                        for (let name of names) caches.delete(name);
                    });
                }
                
                // Load CSV data
                loadCSVFromFile();
            }, []);
            
            const loadCSVFromFile = async () => {
                try {
                    // Force cache clear with multiple cache-busting techniques
                    const timestamp = Date.now() + Math.random();
                    const response = await fetch(`real-data.csv?t=${timestamp}&cb=${Math.random()}`, {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    });
                    if (response.ok) {
                        const csvText = await response.text();
                        const processedTasks = await processCSV(csvText);
                        setTasks(processedTasks);
                        return;
                    }
                } catch (error) {
                    // Silently handle error
                }
                
                // No fallback data - if CSV fails to load, show empty state
                setTasks([]);
            };
            
            const handleLogin = (password, cookieAllowed = false) => {
                // Complete cache clearing
                localStorage.clear();
                sessionStorage.clear();
                
                // Clear any cached fetch requests
                if ('caches' in window) {
                    caches.keys().then(function(names) {
                        for (let name of names) caches.delete(name);
                    });
                }
                
                // Save login to cookie if cookie consent was granted
                if (cookieAllowed) {
                    console.log("🔒 Saving login cookie (cookies accepted)");
                    setCookie(StorageKeys.LOGIN_COOKIE, password);
                } else {
                    console.log("🚫 Not saving login cookie (cookies declined)");
                }

                setIsLoggedIn(true);
                setError('');
                
                // Force reload fresh CSV data with delay to ensure cache is cleared
                setTimeout(() => {
                    loadCSVFromFile();
                }, 100);
            };
            
            const handleWrongPassword = () => {
                setError('Falsches Passwort. Bitte versuchen Sie es erneut.');
            };
            
            const handleLogout = () => {
                setIsLoggedIn(false);
                setError('');
                // Clear login cookie
                deleteCookie(StorageKeys.LOGIN_COOKIE);
                console.log("🚪 Logged out and cleared login cookie");
            };
            
            // Memoize tasks to prevent unnecessary re-renders (MUST be before conditional return)
            const memoizedTasks = React.useMemo(() => {
                console.log('🔄 Memoizing tasks array, length:', tasks.length);
                return tasks;
            }, [tasks.length]); // Only re-memoize if tasks count changes, not the array reference
            
            if (!isLoggedIn) {
                return (
                    <>
                        {showCookieConsent && 
                            <CookieBanner 
                                onAccept={handleCookieAccept} 
                                onDecline={handleCookieDecline} 
                            />
                        }
                        <LoginPage onLogin={handleLogin} onWrongPassword={handleWrongPassword} error={error} />
                    </>
                );
            }
            
            return (
                <>
                    {showCookieConsent && 
                        <CookieBanner 
                            onAccept={handleCookieAccept} 
                            onDecline={handleCookieDecline} 
                        />
                    }
                    <TaskViewer 
                        tasks={memoizedTasks}
                        onLogout={handleLogout}
                    />
                </>
            );
        };
        
        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>


    
</body>
</html>



